'\" t
.TH groff @MAN7EXT@ "@MDATE@" "groff @VERSION@"
.SH Name
groff \- GNU roff language reference
.
.
.\" ====================================================================
.\" Legal Terms
.\" ====================================================================
.\"
.\" Copyright (C) 2000-2018, 2020-2021 Free Software Foundation, Inc.
.\"
.\" This file is part of groff, the GNU roff type-setting system.
.\"
.\" Permission is granted to copy, distribute and/or modify this
.\" document under the terms of the GNU Free Documentation License,
.\" Version 1.3 or any later version published by the Free Software
.\" Foundation; with no Invariant Sections, with no Front-Cover Texts,
.\" and with no Back-Cover Texts.
.\"
.\" A copy of the Free Documentation License is included as a file
.\" called FDL in the main directory of the groff source package.
.
.
.\" Save and disable compatibility mode (for, e.g., Solaris 10/11).
.do nr *groff_groff_7_man_C \n[.cp]
.cp 0
.
.
.\" ====================================================================
.\" Setup
.\" ====================================================================
.
.
.\" ====================================================================
.\" start of macro definitions
.
.de TPx
.  TP 10n
..
.\" ====================================================================
.\" .Text anything ...
.\"
.\" All arguments are printed as text.
.\"
.de Text
.  nop \)\\$*
..
.
.\" ========= command=line option =========
.
.de option
.  Text \f[CB]\\$*
.  ft P
..
.
.\" ========= characters =========
.
.de squoted_char
.  Text \[oq]\f[CB]\\$1\f[]\[cq]\\$2
..
.de dquoted_char
.  Text \[lq]\f[CB]\\$1\f[]\[rq]\\$2
..
.\" ========= requests =========
.
.\" synopsis of a request
.de REQ
.  ie \\n[.$]=1 \{\
.    Text \f[CB]\\$1\f[]
.  \}
.  el \{\
.    Text \f[CB]\\$1\~\f[]\f[I]\\$2\f[]
.  \}
..
.
.\" reference of a request
.de request
.  ie (\\n[.$] < 2) \
.    B \\$*
.  el \
.    BR \\$*
..
.
.\" ========= numerical elements =========
.
.\" number with a trailing unit
.de scalednumber
.  Text \\$1\^\f[CB]\\$2\f[]\\$3\f[R]
.  ft P
..
.
.\" representation of units within the text
.de scaleindicator
.  Text \f[CB]\\$1\f[]\\$2\f[R]
.  ft P
..
.
.\" representation of mathematical operators within the text
.de operator
.  squoted_char \\$@
..
.
.
.\" ========= escape sequences =========
.
.\" ====================================================================
.\" .ESC name [arg]
.\"
.\" Synopsis of an escape sequence, optionally with argument
.\" Args   : 1 or 2; 'name' obligatory, 'arg' optional
.\"   name : suitable name for an escape sequence (c, (xy, [long])
.\"   arg  : arbitrary word
.\" Result : prints \namearg, where 'name' is in CB, 'arg' in I
.\"
.de ESC
.  Text "\f[CB]\e\\$1\,\f[I]\\$2\/\fR"
..
.\" ====================================================================
.\" .ESC[] name arg
.\"
.\" Synopsis for escape sequence with a bracketed long argument
.\" Args   : 2 obligatory
.\"   name : suitable name for an escape sequence (c, (xy, [long])
.\"   arg  : arbitrary text
.\" Result : prints \name[arg], where 'name' is in CB, 'arg' in I
.\"
.de ESC[]
.  Text "\f[CB]\e\\$1\[lB]\f[]\,\f[I]\\$2\/\f[]\f[CB]\[rB]\f[]"
..
.\" ====================================================================
.\" .ESCq name arg
.\"
.\" Synopsis for escape sequence with a bracketed long argument
.\" Args   : 2 obligatory
.\"   name : suitable name for an escape sequence (c, (xy, [long])
.\"   arg  : arbitrary text
.\" Result : prints \name'arg', where 'name' is in CB, 'arg' in I
.\"
.de ESCq
.  Text "\f[CB]\e\\$1\[aq]\f[]\,\f[I]\\$2\/\f[]\f[CB]\[aq]\f[]"
..
.\" ====================================================================
.\" .ESC? arg
.\"
.\" Synopsis for escape sequence with a bracketed long argument
.\" Args   : 1 obligatory
.\"   arg  : arbitrary text
.\" Result : prints '\?arg\?', where the '\?' are in CB, 'arg' in I
.\"
.de ESC?
.  Text "\f[CB]\e?\,\f[I]\\$1\/\f[CB]\[rs]?\f[R]"
..
.\" ====================================================================
.\" .esc name [punct]
.\"
.\" Reference of an escape sequence (no args), possibly punctuation
.\" Args    : 1 obligatory
.\"   name  : suitable name for an escape sequence (c, (xy, [long])
.\"   punct : arbitrary
.\" Result  : prints \name, where 'name' is in B, 'punct' in R
.\"
.de esc
.  ie (\\n[.$] < 2) \
.    B "\e\\$1"
.  el \
.    BR "\e\\$1" \\$2
..
.\" ====================================================================
.\" .escarg name arg [punct]
.\"
.\" Reference of an escape sequence (no args)
.\" Args    : 1 obligatory, 1 optional
.\"   name  : suitable name for an escape sequence (c, (xy, [long])
.\"   arg   : arbitrary word
.\" Result  : prints \namearg, where
.\"           'name' is in B, 'arg' in I
.\"
.de escarg
.  Text \f[B]\e\\$1\f[]\,\f[I]\\$2\/\f[]\\$3
..
.\" ====================================================================
.\" .esc[] name arg [punct]
.\"
.\" Reference for escape sequence with a bracketed long argument
.\" Args   : 2 obligatory
.\"   name : suitable name for an escape sequence (c, (xy, [long])
.\"   arg  : arbitrary text
.\" Result : prints \name[arg], where 'name' is in CB, 'arg' in CI
.\"
.de esc[]
.  Text \f[CB]\e\\$1\[lB]\f[]\,\f[CI]\\$2\/\f[]\f[CB]\[rB]\f[]\\$3
..
.
.\" ========= strings =========
.
.\" synopsis for string, with \*[]
.de STRING
.  Text \[rs]*[\f[CB]\\$1\f[]] \\$2
..
.\" synopsis for a long string
.de string
.  if \n[.$]=0 \
.    return
.  Text \f[CB]\[rs]*\[lB]\\$1\[rB]\f[]\\$2
..
.
.\" ========= registers =========
.
.\" synopsis for registers, with \n[]
.de REG
.  Text \[rs]n[\f[CB]\\$1\f[]]
..
.\" reference of a register, without decoration
.de register
.  Text register
.  ie (\\n[.$] < 2) \
.    B \\$*
.  el \
.    BR \\$*
..
.
.\" end of macro definitions
.
.
.\" ====================================================================
.SH Description
.\" ====================================================================
.
.P
The name
.I groff
stands for
.I GNU roff
and is the free implementation of the roff type-setting system.
.
See
.BR roff (@MAN7EXT@)
for a survey and the background of the groff system.
.
.
.P
This document provides only short descriptions of roff language
elements.
.
.IR "Groff: The GNU Implementation of troff" ,
by Trent A.\& Fisher and Werner Lemberg,
is the primary
.I groff
manual,
and is written in Texinfo.
.
You can browse it interactively with \[lq]info groff\[rq].
.
.
.P
Historically, the
.I roff language
was called
.IR troff .
.I groff
is compatible with the classical system and provides proper
extensions.
.
So in GNU, the terms
.IR roff ,
.IR troff ,
and
.I groff language
could be used as synonyms.
.
However
.I troff
slightly tends to refer more to the classical aspects, whereas
.I groff
emphasizes the GNU extensions, and
.I roff
is the general term for the language.
.
.
.P
The general syntax for writing groff documents is relatively easy, but
writing extensions to the roff language can be a bit harder.
.
.
.P
The roff language is line-oriented.
.
There are only two kinds of lines, control lines and text lines.
.
The control lines start with a control character, by default a period
.dquoted_char .
or a single quote
.dquoted_char \[aq] ;
all other lines are text lines.
.
.
.P
.B Control lines
represent commands, optionally with arguments.
.
They have the following syntax.
.
The leading control character can be followed by a command name;
arguments, if any, are separated by spaces (but not tab characters)
from the command name and among themselves, for example,
.RS
.P
.Text .command_name arg1 arg2
.RE
.
.
.P
For indentation, any number of space or tab characters can be inserted
between the leading control character and the command name, but the
control character must be on the first position of the line.
.
.
.P
.B Text lines
represent the parts that is printed.
They can be modified by escape sequences, which are recognized by a
leading backslash
.squoted_char \[rs] .
These are in-line or even in-word formatting elements or functions.
.
Some of these take arguments separated by single quotes
.dquoted_char \[aq] ,
others are regulated by a length encoding introduced by an open
parenthesis
.squoted_char (
or enclosed in brackets
.squoted_char [
and
.squoted_char ] .
.
.
.\" ====================================================================
.SH "\f[I]groff\f[] elements"
.\" ====================================================================
.
The roff language elements add formatting information to a text file.
.
The fundamental elements are predefined commands and variables that
make roff a full-blown programming language.
.
.
.P
There are two kinds of roff commands, possibly with arguments.
.B Requests
are written on a line of their own starting with a dot
.squoted_char .\&
or a
.dquoted_char \[aq] ,
whereas
.B Escape sequences
are in-line functions and in-word formatting elements starting with a
backslash
.squoted_char \[rs] .
.
.
.P
The user can define her own formatting commands using the
.request .de
request.
.
These commands are called
.BR macros ,
but they are used exactly like requests.
.
Macro packages are pre-defined sets of macros written in the groff
language.
.
A user's possibilities to create escape sequences herself is very
limited, only special characters can be mapped.
.
.
.P
The groff language provides several kinds of variables with
different interfaces.
.
There are pre-defined variables, but the user can define her own
variables as well.
.
.
.P
.B String
variables store character sequences.
.
They are set with the
.request .ds
request and retrieved by the
.esc *
escape sequences.
.
Strings can have variables.
.
.
.P
.B Register
variables can store numerical values, numbers with a scale unit, and
occasionally string-like objects.
.
They are set with the
.request .nr
request and retrieved by the
.esc n
escape sequences.
.
.
.P
.B Environments
allow the user to temporarily store global formatting parameters like
line length, font size, etc.\& for later reuse.
.
This is done by the
.request .ev
request.
.
.
.P
.B Fonts
are identified either by a name or by an internal number.
.
The current font is chosen by the
.request .ft
request or by the
.esc f
escape sequences.
.
Each device has special fonts, but the following fonts are available
for all devices.
.B R
is the standard font Roman.
.B B
is its
.B bold
counterpart.
.
The
.I italic
font is called
.B I
and is available everywhere, but on text devices it is displayed as an
underlined Roman font.
.
For the graphical output devices, there exist constant-width pendants
of these fonts,
.BR CR ,
.BR CI ,
and
.BR CB .
On text devices, all glyphs have a constant width anyway.
.
.
.P
.B Glyphs
are visual representation forms of
.BR characters .
In groff, the distinction between those two elements is not always
obvious (and a full discussion is beyond the scope of this man page).
.
A first approximation is that glyphs have a specific size and
colour and are taken from a specific font; they can't be modified any
more \[en] characters are the input, and glyphs are the output.
.
As soon as an output line has been generated, it no longer contains
characters but glyphs.
.
In this man page, we use either \[oq]glyph\[cq] or
\[oq]character\[cq], whatever is more appropriate.
.
A few characters commonly seen on keyboards are treated
specially by
.I roff
languages and may not look correct in output;
they are
the (double) quotation mark
.RB ( \[dq] ),
the apostrophe
.RB ( \[aq] ),
the minus sign
.RB ( \- ),
the backslash
.RB ( \[rs] ),
the caret or circumflex accent
.RB ( \[ha] ),
the grave accent
.RB ( \[ga] ),
and the tilde
.RB ( \[ti] ).
.
All are available if required;
see
.IR groff_char (@MAN7EXT@).
.
.
.P
Moreover, there are some advanced roff elements.
.
A
.B diversion
stores (formatted) information into a macro for later usage.
See
.BR groff_tmac (@MAN5EXT@)
for more details.
.
A
.B trap
is a positional condition like a certain number of lines from page top
or in a diversion or in the input.
.
Some action can be prescribed to be run automatically when the
condition is met.
.
.
.P
More detailed information and examples can be found in the
.I groff
Texinfo manual.
.
.
.\" ====================================================================
.SH "Control characters"
.\" ====================================================================
.
There is a small set of characters that have a special controlling
task in certain conditions.
.
.TP
\&\f[CB].\f[]
A dot is only special at the beginning of a line or after the
condition in the requests
.request .if ,
.request .ie ,
.request .el ,
and
.request .while .
.
There it is the control character that introduces a request (or macro).
.
By using the
.request .cc
request, the control character can be set to a different character,
making the dot
.squoted_char .\&
a non-special character.
.
.IP
In all other positions, it just means a dot character.
.
In text paragraphs, it is advantageous to start each sentence at a
line of its own.
.
.TP
\&\f[CB]\[aq]\f[]
The apostrophe has two controlling tasks.
.
At the beginning of a line and in the conditional requests it is the
no-break control character.
.
That means that it introduces a request like the dot, but with the
additional property that this request doesn't cause a linebreak.
.
The no-break control character can be changed with the
.request .c2
request.
.
.IP
As a second task, it is the most commonly used argument separator in
some functional escape sequences (but any pair of characters not part
of the argument do work).
.
In all other positions, it denotes a single quote or apostrophe
character, depending on the output device's glyph repertoire.
.
.I groff
provides a printable representation with the
.esc (aq
escape sequence.
.
.TP
\&\f[CB]\[dq]\f[]
The double quote can be used to enclose arguments to macros and strings,
but not requests.
.
In the
.request .ds ,
.request .ds1 ,
.request .as ,
and
.request .as1
requests,
a leading double quote in the second argument is stripped off,
enabling the inclusion of leading space characters in the string
definition or appendment.
.
The escaped double quote
.esc \[dq]
introduces a comment.
.
Otherwise, it is not special.
.
.I groff
provides a printable representation with the
.esc [dq]
escape sequence.
.
.TP
\&\f[CB]\e\f[]
The backslash usually introduces an escape sequence (this can be
changed with the
.request .ec
request).
.
A printed version of the escape character is the
.esc e
escape; a backslash glyph can be obtained by
.esc (rs .
.
.TP
\&\f[CB](\f[]
The open parenthesis is only special in escape sequences when
introducing an escape name or argument consisting of exactly two
characters.
.
In groff, this behaviour can be replaced by the \f[CB][]\f[] construct.
.
.TP
\&\f[CB][\f[]
The opening bracket is only special in groff escape sequences; there
it is used to introduce a long escape name or long escape argument.
.
Otherwise, it is non-special, e.g., in macro calls.
.
.TP
\&\f[CB]]\f[]
The closing bracket is only special in groff escape sequences; there
it terminates a long escape name or long escape argument.
.
Otherwise, it is non-special.
.
.
.TP
\f[CI]space\f[]
Space characters separate arguments in request invocations,
macro calls,
and string interpolations.
.
In text,
they separate words.
.
Multiple adjacent space characters in text cause
.I groff
to attempt end-of-sentence detection on the preceding word
(and trailing punctuation).
.
The amount of space between words and sentences is controlled by the
.request .ss
request.
.
When filling is enabled
(the default),
a line may be broken at a space.
.
When adjustment is enabled and set to both margins
(the default),
inter-word spaces may be expanded to justify the line.
.
To get a space of definite width,
use the escape sequences
.squoted_char "\[rs]\ "
(this is the escape character followed by a space),
.esc 0 ,
.esc | ,
.esc \[ha] ,
or
.esc h ;
see section \[lq]Escape sequences\[rq] below.
.
An adjustable but non-breaking space is available with
.esc \[ti] .
.
.
.IP \f[CI]newline\f[]
In text,
a newline puts an inter-word space onto the output and triggers
end-of-sentence recognition on the preceding text.
.
See section \[lq]Line continuation\[rq] below.
.
.IP \f[CI]tab\f[]
If a tab character occurs during text the interpreter makes a
horizontal jump to the next pre-defined tab position.
.
There is a sophisticated interface for handling tab positions.
.
.
.\" ====================================================================
.SH "Line continuation"
.\" ====================================================================
.
A backslash
.B \[rs]
at the end of a line immediately followed by a newline suppresses the
effects of that newline on the input.
.
The next input line thus retains the classification of its predecessor
as a control or text line.
.
The
.esc c
escape sequence continues an output line.
.
Anything on the input line after
.esc c
is ignored except
.esc R ,
which works as usual.
.
In contrast to
.BI \[rs] newline\c
,
a line after
.esc c
is treated as a new input line,
so a control character is recognized at its beginning.
.
The visual results depend on whether filling is enabled.
.
An intervening control line that causes a break overrides
.esc c ,
flushing out the pending output line in the usual way.
.
The
.register .int
contains a positive value if the last output line was continued with
.esc c ;
this datum is associated with the
environment.
.
.
.\" ====================================================================
.SH "Numerical expressions"
.\" ====================================================================
.
A
.B numerical value
is a signed or unsigned integer or float with or without an appended
scaling indicator.
.
A
.B scaling indicator
is a one-character abbreviation for a unit of measurement.
.
A number followed by a scaling indicator signifies a size value.
.
By default, numerical values do not have a scaling indicator, i.e., they
are normal numbers.
.
.
.P
The
.I roff
language defines the following scaling indicators.
.
.
.P
.PD 0
.RS
.
.TPx
.B c
centimeter
.
.TPx
.B i
inch
.
.TPx
.B P
pica\ \[eq]\ 1/6\ inch
.
.TPx
.B p
point\ \[eq]\ 1/72\ inch
.
.TPx
.B m
em\ \[eq]\ \f[R]the font size in points (approx.\& width of letter
\[oq]\f[CR]m\f[R]\[cq])
.
.TPx
.B M
100\^th \f[R]of an \f[CR]em
.
.TPx
.B n
en\ \[eq]\ em/2
.
.TPx
.B u
Basic unit for output device
.
.TPx
.B v
vee (vertical line space)
.
.TPx
.B s
scaled point\ \[eq]\ 1/\f[CI]sizescale\f[R] of a point (defined in
font \f[I]DESC\f[] file)
.
.TPx
.B f
Scale by 65536.
.RE
.PD
.
.
.P
.B Numerical expressions
are combinations of the numerical values defined above with the
following arithmetical operators already defined in classical troff.
.
.
.P
.PD 0
.RS
.
.TPx
.B +
Addition
.
.TPx
.B \-
Subtraction
.
.TPx
.B *
Multiplication
.
.TPx
.B /
Division
.
.TPx
.B %
Modulo
.
.TPx
.B =
Equals
.
.TPx
.B ==
Equals
.
.TPx
.B <
Less than
.
.TPx
.B >
Greater than
.
.TPx
.B <=
Less or equal
.
.TPx
.B >=
Greater or equal
.
.TPx
.B &
Logical and
.
.TPx
.B :
Logical or
.
.TPx
.B !
Logical not
.
.TPx
.B (
Grouping of expressions
.
.TPx
.B )
Close current grouping
.
.RE
.PD
.
.
.P
Moreover,
.I groff
provides the following additional operators for numerical expressions.
.
.
.P
.PD 0
.RS
.
.TPx
\f[I]e1\/\f[CB]>?\,\f[I]e2\f[R]
The maximum of
.I e1
and
.IR e2 .
.
.TPx
\f[I]e1\/\f[CB]<?\,\f[I]e2\f[R]
The minimum of
.I e1
and
.IR e2 .
.
.TPx
\f[CB](\,\f[I]c\/\f[CB];\,\f[I]e\/\f[CB])\f[R]
Evaluate
.I e
using
.I c
as the default scaling indicator.
.
.RE
.PD
.
.
.P
For details see the
.I groff
Texinfo manual.
.
.
.\" ====================================================================
.SH "Control structures"
.\" ====================================================================
.
.I groff
has \[lq]if\[rq] and \[lq]while\[rq] control structures like other
languages.
.
However,
the syntax for grouping multiple input lines in the branches or bodies
of these structures is unusual.
.
.
.P
They have a common form:
the request name is
(except for
.request .el
\[lq]else\[rq])
followed by a conditional expression
.IR cond-expr ,
and then the remainder of the line
.I anything
is interpreted as if it were an input line.
.
Any number of spaces between arguments to requests serves only to
separate them;
leading spaces in
.I anything
are therefore not seen.
.
.I anything
effectively
.I cannot
be omitted;
if
.I cond-expr
is true and
.I anything
is empty,
the newline at the end of the control line is interpreted as a blank
line
(and therefore a blank text line).
.
.
.P
It is frequently desirable for a control structure to govern more than
one request,
call more than one macro,
span more than one input line of text,
or mix the foregoing.
.
The opening and closing brace escapes
.esc {
and
.esc }
perform such grouping.
.
Brace escapes can be used outside of control structures,
but when they are they have no meaning and produce no output.
.
.
.P
.esc {
should appear
(after optional spaces and tabs)
immediately subsequent to the request's conditional expression.
.
.esc }
should appear on a line with other occurrences of itself as necessary to
match
.esc {
escapes.
.
It can be preceded by a control character,
spaces,
and tabs.
.
Input after a
.esc }
escape on the same line is only processed if all the preceding
conditions to which the escapes correspond are true.
.
Furthermore,
a
.esc }
closing the body of a
.request .while
request must be the last such escape on an input line.
.
.
.\" ====================================================================
.SS "Conditional expressions"
.\" ====================================================================
.
In
.request .if ,
.request .ie ,
and
.request .while
requests,
in addition to the numeric expressions described above,
several Boolean operators are available;
the members of this expanded class are termed
.IR "conditional expressions" .
.
.
.P
A numerical expression
.I expr
is true if its value is positive.
.
In
.I roff
languages,
negative values are false.
.
The truth values of other conditional expression operators are as shown
below.
.
.
.P
.ne 14v
.TS
rf(BI) lB
rB lx.
cond-expr\f[R].\|.\|.	.\|.\|.is true if.\|.\|.
_
T{
.BI \[aq] s1 \[aq] s2 \[aq]
T}	T{
.I s1
produces the same formatted output as
.IR s2 .
T}
T{
.BI c\~ g
T}	T{
a glyph
.I g
is available.
T}
T{
.BI d\~ m
T}	T{
a string,
macro,
diversion,
or request
.I m
is defined.
T}
e	T{
the current page number is even.
T}
T{
.BI F\~ f
T}	T{
a font named
.I f
is available.
T}
T{
.BI m\~ c
T}	T{
a color named
.I c
is defined.
T}
n	T{
the formatter is in
.I nroff
mode.
T}
o	T{
the current page number is odd.
T}
T{
.BI r\~ n
T}	T{
a register named
.I n
is defined.
T}
T{
.BI S\~ s
T}	T{
a font style named
.I s
is available.
T}
t	T{
the formatter is in
.I troff
mode.
T}
v	T{
n/a
(historical artifact;
always false).
T}
.TE
.
.
.P
These operators can't be combined with others like
.RB \[lq] : \[rq]
or
.RB \[lq] & \[rq];
only a leading
.RB \[lq] ! \[rq]\&
can be used to complement the result.
.
Spaces and tabs are optional immediately after the
.RB \[lq] c \[rq],
.RB \[lq] d \[rq],
.RB \[lq] F \[rq],
.RB \[lq] m \[rq],
.RB \[lq] r \[rq],
and
.RB \[lq] S \[rq]
operators,
but immediately after
.RB \[lq] ! \[rq],
they cause the condition to evaluate false
(this bizarre behavior maintains compatibility with AT&T
.IR troff ).
.
.
.\" ====================================================================
.SH "Syntax reference conventions"
.\" ====================================================================
.
In the following request and escape sequence specifications,
most argument names were chosen to be descriptive.
.
A few denotations may require introduction.
.
.
.P
.PD 0
.RS
.
.TPx
.I c
denotes a single input character.
.
.TPx
.I font
a font either specified as a font name or a numeric mounting position.
.
.TPx
.I anything
all characters up to the end of the line,
to the ending delimiter for the escape sequence,
or within
.esc {
and
.esc } .
.
Escape sequences may generally be used freely in
.IR anything ,
except when it is read in copy mode.
.
.TPx
.I n
is a numerical expression that evaluates to an integer value.
.
.TPx
.I N
is an optionally-signed numerical expression.
.
.TPx
.I \[+-]N
has three meanings,
depending on its sign.
.
.RE
.PD
.
.
.P
If a numeric expression presented as
.I \[+-]N
starts with a
.squoted_char +
sign,
an increment in the amount of
.RI of\~ N
is applied to the value applicable to the request or escape sequence.
.
If it starts with a
.squoted_char \-
sign,
a decrement of magnitude
.I N
is applied instead.
.
Without a sign,
.I N
replaces any existing value.
.
To assign a negative number,
either prefix the expression with a zero or enclose it with parentheses.
.
If a prior value does not exist,
an increment or decrement is applied as if to\~0.
.
.
.\" ====================================================================
.SH Requests
.\" ====================================================================
.
In
.IR groff ,
identifier names,
including those of requests,
can be arbitrarily long.
.
No bracketing or marking of long names is needed in request invocation
syntax.
.
.
.P
Most requests take one or more arguments.
.
Tabs are permitted after a request name,
before its first argument
(if any),
but arguments themselves must be separated only by space characters.
.
There is no inherent limit on argument length or quantity.
.
.
.P
Not all details of request behavior are outlined here.
.
Refer to the
.I groff
Texinfo manual or
.IR groff_diff (@MAN7EXT@).
.
.
.\" ====================================================================
.SS "Request short reference"
.\" ====================================================================
.
.PD 0
.
.TPx
.REQ .ab "string"
Write
.I string
to the standard error stream and exit with failure status.
.
.
.TPx
.REQ .ad
Enable output line adjustment using mode stored in
.BR \[rs]n[.j] .
.
.
.TPx
.REQ .ad c
Enable output line adjustment in mode
.I c
.RI ( c =\c
.BR b , c , l , n , r ).
.
Sets
.BR \[rs]n[.j] .
.
.
.TPx
.REQ .af "register c"
Assign format
.I c
to
.IR register ,
where
.I c
is
.RB \[lq] i \[rq],
.RB \[lq] I \[rq],
.RB \[lq] a \[rq],
.RB \[lq] A \[rq],
or a sequence of decimal digits whose quantity denotes the minimum width
in digits to be used when the register is interpolated.
.
.RB \[lq] i \[rq]
and
.RB \[lq] a \[rq]
indicate Roman numerals and base-26 Latin alphabetics,
respectively,
in the lettercase specified.
.
The default is \[lq]0\[rq].
.
.
.TPx
.REQ .aln "new old"
Create alias
(additional name)
.I new
for existing number register named
.IR old .
.
.TPx
.REQ .als "new old"
Create alias
(additional name)
.I new
for existing request,
string,
macro,
or diversion
.IR old .
.
.TPx
.REQ .am "macro"
Append to
.I macro
until
.B ..\&
is encountered.
.
.TPx
.REQ .am "macro end"
Append to
.I macro
until
.BI . end
is called.
.
.TPx
.REQ .am1 "macro"
Same as
.request .am
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .am1 "macro end"
Same as
.request .am
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .ami "macro"
Append to a macro whose name is contained in the string register
.I macro
until
.B ..\&
is encountered.
.
.TPx
.REQ .ami "macro end"
Append to a macro indirectly.
.I macro
and
.I end
are string registers whose contents are interpolated for the macro name
and the end macro, respectively.
.
.TPx
.REQ .ami1 "macro"
Same as
.request .ami
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .ami1 "macro end"
Same as
.request .ami
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .as "name \fR[\fPstring\fR]\fP"
Append
.I string
to the string
.IR name ;
no operation if
.I string
is omitted.
.
.
.TPx
.REQ .as1 "name \fR[\fPstring\fR]\fP"
Same as
.request .as
but with compatibility mode switched off during string expansion.
.
.
.TPx
.REQ .asciify "diversion"
Unformat ASCII characters, spaces, and some escape sequences in
.IR diversion .
.
.TPx
.REQ .backtrace
Write a backtrace of the input stack to the standard error stream.
.
Also see the
.B \-b
option of
.IR groff (@MAN1EXT@).
.
.TPx
.REQ .bd "font N"
Embolden
.I font
by
.IR N \-1
units.
.
.TPx
.REQ .bd "S font N"
Embolden Special Font
.I S
when current font is
.IR font .
.
.
.TPx
.REQ .blm
Unset blank line macro (trap).
.
Restore default handling of blank lines.
.
.
.TPx
.REQ .blm name
Set blank line macro (trap) to
.IR name .
.
.
.TPx
.REQ .box
Stop directing output to current box diversion.
.
.
.TPx
.REQ .box "name"
Divert output to
.IR name ,
omitting a partially collected line.
.
.
.TPx
.REQ .boxa
Stop appending output to current box diversion.
.
.
.TPx
.REQ .boxa "name"
Divert output,
appending it to
.IR name ,
omitting a partially collected line.
.
.
.TPx
.REQ .bp
Eject current page and begin new page.
.
.TPx
.REQ .bp "\[+-]N"
Eject current page; next page number
.IR \[+-]N .
.
.TPx
.REQ .br
Line break.
.
.TPx
.REQ .brp
Break output line; adjust if applicable.
.
.TPx
.REQ .break
Break out of a while loop.
.
.TPx
.REQ .c2
Reset no-break control character to
.dquoted_char \[aq] .
.
.TPx
.REQ .c2 "c"
Set no-break control character to
.IR c .
.
.TPx
.REQ .cc
Reset control character to
.squoted_char . .
.
.TPx
.REQ .cc "c"
Set control character to
.IR c .
.
.TPx
.REQ .ce
Center the next input line.
.
.TPx
.REQ .ce "N"
Center following
.I N
input lines.
.
.TPx
.REQ .cf "filename"
Copy contents of file
.I filename
unprocessed to stdout or to the diversion.
.
.TPx
.REQ .cflags "n c1 c2 \fR\&.\|.\|.\&\fP"
Assign properties encoded by the number
.I n
to characters
.IR c1 ,
.IR c2 ,
and so on.
.
.
.TPx
.REQ .ch "name N"
Change location of page location trap by moving macro
.I name
to new location
.IR N ,
or by unplanting it altogether if
.I N
absent.
.
.
.TPx
.REQ .char "c anything"
Define entity
.I c
as string
.IR anything .
.
.TPx
.REQ .chop object
Remove the last character from the macro,
string,
or diversion
named
.IR object .
.
.TPx
.REQ .class "name c1 c2 \fR\&.\|.\|.\&\fP"
Define a (character) class
.I name
comprising the characters or range expressions
.IR c1 ,
.IR c2 ,
and so on.
.
.TPx
.REQ .close "stream"
Close the
.IR stream .
.
.TPx
.REQ .color
Enable colors.
.
.TPx
.REQ .color "N"
If
.I N
is zero disable colors, otherwise enable them.
.
.TPx
.REQ .composite "from to"
Map glyph name
.I from
to glyph name
.I to
while constructing a composite glyph name.
.
.TPx
.REQ .continue
Finish the current iteration of a while loop.
.
.TPx
.REQ .cp
Enable compatibility mode.
.
.TPx
.REQ .cp "N"
If
.I N
is zero disable compatibility mode, otherwise enable it.
.
.TPx
.REQ .cs "font N M"
Set constant character width mode for
.I font
to
.IR N /36
ems with em
.IR M .
.
.TPx
.REQ .cu "N"
Continuous underline in nroff, like
.request .ul
in troff.
.
.TPx
.REQ .da
End current diversion.
.
.TPx
.REQ .da "macro"
Divert and append to
.IR macro .
.
.TPx
.REQ .de "macro"
Define or redefine
.I macro
until
.B ..\&
is encountered.
.
.TPx
.REQ .de "macro end"
Define or redefine
.I macro
until
.BI . end
is called.
.
.TPx
.REQ .de1 "macro"
Same as
.request .de
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .de1 "macro end"
Same as
.request .de
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .defcolor "color scheme component"
Define or redefine a color with name
.IR color .
.I scheme
can be
.BR rgb ,
.BR cym ,
.BR cymk ,
.BR gray ,
or
.BR grey .
.I component
can be single components specified as fractions in the range 0 to 1
(default scaling indicator\~\c
.scaleindicator f ),
as a string of two-digit hexadecimal color components with a leading
.BR # ,
or as a string of four-digit hexadecimal components with two leading
.BR # .
The color
.B default
can't be redefined.
.
.TPx
.REQ .dei "macro"
Define or redefine a macro whose name is contained in the string
register
.I macro
until
.B ..\&
is encountered.
.
.TPx
.REQ .dei "macro end"
Define or redefine a macro indirectly.
.I macro
and
.I end
are string registers whose contents are interpolated for the macro name
and the end macro, respectively.
.
.TPx
.REQ .dei1 "macro"
Same as
.request .dei
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .dei1 "macro end"
Same as
.request .dei
but with compatibility mode switched off during macro expansion.
.
.TPx
.REQ .device "anything"
Write
.I anything
to the intermediate output as a device control function.
.
.TPx
.REQ .devicem "name"
Write contents of macro or string
.I name
uninterpreted to the intermediate output as a device control function.
.
.TPx
.REQ .di
End current diversion.
.
.TPx
.REQ .di "macro"
Divert to
.IR macro .
See
.BR groff_tmac (@MAN5EXT@)
for more details.
.
.TPx
.REQ .do "name \fR\&.\|.\|.\&\fP"
Interpret the string,
request,
diversion,
or macro
.I name
(along with any arguments)
with compatibility mode disabled.
.
Note that compatibility mode is restored
(if and only if it was active)
when the
.I expansion
of
.I name
is interpreted.
.
.TPx
.REQ .ds "name \fR[\fPstring\fR]\fP"
Define a string variable
.I name
with contents
.IR string ,
or as empty if
.I string
is omitted.
.
.
.TPx
.REQ .ds1 "name \fR[\fPstring\fR]\fP"
Same as
.request .ds
but with compatibility mode switched off during string expansion.
.
.
.TPx
.REQ .dt
Clear diversion trap.
.
.
.TPx
.REQ .dt "N name"
Set diversion trap to
macro
.I name
at position
.I N
(default scaling indicator\~\c
.scaleindicator v ).
.
.
.TPx
.REQ .ec
Set escape character to
.squoted_char \[rs] .
.
.
.TPx
.REQ .ec "c"
Set escape character to
.IR c .
.
.
.TPx
.REQ .ecr
Restore escape character saved with
.request .ecs .
.
.
.TPx
.REQ .ecs
Save current escape character.
.
.
.TPx
.REQ .el "anything"
Interpret
.I anything
as if it were an input line if the conditional expression of the
corresponding
.request .ie
request was false.
.
.
.TPx
.REQ .em name
Invoke macro
.I name
after the end of input.
.
.
.TPx
.REQ .eo
Unset escape character,
turning off escape interpretation.
.
.
.TPx
.REQ .ev
Pop environment stack,
returning to previous one.
.
.
.TPx
.REQ .ev "env"
Push current environment onto stack and switch to
.IR env .
.
.
.TPx
.REQ .evc "env"
Copy environment
.I env
to the current one.
.
.
.TPx
.REQ .ex
Exit with successful status.
.
.
.TPx
.REQ .fam
Return to previous font family.
.
.TPx
.REQ .fam "name"
Set the current font family to
.IR name .
.
.TPx
.REQ .fc
Disable field mechanism.
.
.TPx
.REQ .fc "a"
Set field delimiter to\~\c
.I a
and pad glyph to space.
.
.TPx
.REQ .fc "a b"
Set field delimiter to\~\c
.I a
and pad glyph to\~\c
.IR b .
.
.TPx
.REQ .fchar "c anything"
Define fallback character (or glyph)
.I c
as string
.IR anything .
.
.TPx
.REQ .fcolor
Set fill color to previous fill color.
.
.TPx
.REQ .fcolor "c"
Set fill color to
.IR c .
.
.
.TPx
.REQ .fi
Enable filling of output lines;
a pending output line is broken.
.
Sets
.BR \[rs]n[.u] .
.
.
.TPx
.REQ .fl
Flush output buffer.
.
.TPx
.REQ .fp "n font"
Mount
.I font
on position
.IR n .
.
.TPx
.REQ .fp "n internal external"
Mount font with long
.I external
name to short
.I internal
name on position
.IR n .
.
.TPx
.REQ .fschar "f c anything"
Define fallback character (or glyph)
.I c
for font
.I f
as string
.IR anything .
.
.TPx
.REQ .fspecial "font"
Reset list of special fonts for
.I font
to be empty.
.
.TPx
.REQ .fspecial "font s1 s2 \fR\&.\|.\|.\&\fP"
When the current font is
.IR font ,
then the fonts
.IR s1 ,
.IR s2 ,
\&.\|.\|.\&
are special.
.
.TPx
.REQ .ft
Return to previous font.
Same as
.esc f[]
or
.esc fP .
.
.TPx
.REQ .ft "font"
Change to font name or number
.IR font ;
same as
.esc[] f font
escape sequence.
.
.TPx
.REQ .ftr "font1 font2"
Translate
.I font1
to
.IR font2 .
.
.TPx
.REQ .fzoom "font"
Don't magnify
.IR font .
.
.TPx
.REQ .fzoom "font zoom"
Set zoom factor for
.I font
(in multiples of 1/1000th).
.
.TPx
.REQ .gcolor
Set glyph color to previous glyph color.
.
.TPx
.REQ .gcolor "c"
Set glyph color to
.IR c .
.
.TPx
.REQ .hc
Reset the hyphenation character
.RB to\~ \[rs]%
(the default).
.
.TPx
.REQ .hc char
Change the hyphenation character
.RI to\~ char .
.
.TPx
.REQ .hcode "c1 code1 \fR[\fPc2 code2\fR] .\|.\|.\fP"
Set the hyphenation code of character
.I c1
to
.IR code1 ,
that of
.I c2
to
.IR code2 ,
and so on.
.
.TPx
.REQ .hla lang
Set the hyphenation language to
.IR lang .
.
.TPx
.REQ .hlm n
Set the maximum number of consecutive hyphenated lines to
.IR n .
.
.TPx
.REQ .hpf pattern-file
Read hyphenation patterns from
.IR pattern-file .
.
.TPx
.REQ .hpfa pattern-file
Append hyphenation patterns from
.IR pattern-file .
.
.TPx
.REQ .hpfcode "a b \fR[\fPc d\fR] .\|.\|.\fP"
Define mapping values for character codes in pattern files read with the
.request .hpf
and
.request .hpfa
requests.
.
.TPx
.REQ .hw "word \fR.\|.\|.\fP"
Define how each
.I  word
is to be hyphenated,
with each hyphen
.RB \[lq] \- \[rq]
indicating a hyphenation point.
.
.
.TPx
.REQ .hy
Set automatic hyphenation mode to
.BR 1 .
.
.
.TPx
.REQ .hy\~0
Disable automatic hyphenation;
same as
.BR .nh .
.
.
.TPx
.REQ .hy mode
Set automatic hyphenation mode to
.IR mode ;
see section \[lq]Hyphenation\[rq] below.
.
.
.TPx
.REQ .hym
Set the (right) hyphenation margin to
.B 0
(the default).
.
.TPx
.REQ .hym length
Set the (right) hyphenation margin to
.I length
(default scaling indicator\~\c
.scaleindicator m ).
.
.TPx
.REQ .hys
Set the hyphenation space to
.B 0
(the default).
.
.TPx
.REQ .hys hyphenation-space
Suppress hyphenation of the line in adjustment modes
.RB \[lq] b \[rq]
or
.RB \[lq] n \[rq]
if it can be justified by adding no more than
.I hyphenation-space
extra space to each inter-word space
(default scaling indicator\~\c
.scaleindicator m ).
.
.
.TPx
.REQ .ie "cond-expr anything"
If
.I cond-expr
is true,
interpret
.I anything
as if it were an input line,
otherwise skip to a corresponding
.request .el
request.
.
.
.TPx
.REQ .if "cond-expr anything"
If
.I cond-expr
is true,
then interpret
.I anything
as if it were an input line.
.
.
.TPx
.REQ .ig
Ignore text until
.B ..\&
is encountered.
.
.TPx
.REQ .ig "end"
Ignore text until
.BI . end
is called.
.
.TPx
.REQ .in
Change to previous indentation value.
.
.TPx
.REQ .in "\[+-]N"
Change indentation according to
.I \[+-]N
(default scaling indicator\~\c
.scaleindicator m ).
.
.
.TPx
.REQ .it "n name"
Set an input line trap,
calling macro
.IR name ,
after the next
.IR n\~ lines
lines of text input have been read.
.
.
.TPx
.REQ .itc "n name"
As
.request .it ,
but don't count lines interrupted with
.esc c .
.
.
.TPx
.REQ .kern
Enable pairwise kerning.
.
.TPx
.REQ .kern "n"
If
.I n
is zero, disable pairwise kerning, otherwise enable it.
.
.
.TPx
.REQ .lc
Remove leader repetition glyph.
.
.
.TPx
.REQ .lc "c"
Set leader repetition glyph
.RI to\~ c
(default:
.RB \[lq] . \[rq]).
.
.
.TPx
.REQ .length "reg anything"
Compute the number of characters of
.I anything
and store the count
in the number register
.IR reg .
.
.
.TPx
.REQ .linetabs
Enable line-tabs mode
(calculate tab positions relative to beginning of output line).
.
.
.TPx
.REQ .linetabs\~0
Disable line-tabs mode.
.
.
.TPx
.REQ .lf "N"
Set input line number to
.IR N .
.
.TPx
.REQ .lf "N file"
Set input line number to
.I N
and filename to
.IR file .
.
.TPx
.REQ .lg "N"
Ligature mode on if
.IR N >0.
.
.TPx
.REQ .ll
Change to previous line length.
.
.TPx
.REQ .ll "\[+-]N"
Set line length according to
.I \[+-]N
(default length
.scalednumber 6.5 i ,
default scaling indicator\~\c
.scaleindicator m ).
.
.
.TPx
.REQ .lsm
Unset the leading space macro (trap).
.
Restore default handling of lines with leading spaces.
.
.
.TPx
.REQ .lsm name
Set the leading space macro (trap) to
.IR name .
.
.
.TPx
.REQ .ls
Change to the previous value of additional intra-line skip.
.
.TPx
.REQ .ls "N"
Set additional intra-line skip value to
.IR N ,
i.e.,
.IR N \-1
blank lines are inserted after each text output line.
.
.TPx
.REQ .lt "\[+-]N"
Length of title (default scaling indicator\~\c
.scaleindicator m ).
.
.TPx
.REQ .mc
Margin glyph off.
.
.TPx
.REQ .mc "c"
Print glyph\~\c
.I c
after each text line at actual distance from right margin.
.
.TPx
.REQ .mc "c N"
Set margin glyph to\~\c
.I c
and distance to\~\c
.I N
from right margin (default scaling indicator\~\c
.scaleindicator m ).
.
.TPx
.REQ .mk "\fR[\fPregister\fR]\fP"
Mark current vertical position in
.IR register ,
or in an internal register used by
.B .rt
if no argument.
.
.
.TPx
.REQ .mso "file"
As
.request .so ,
except that
.I file
is sought in the
.I tmac
directories.
.
.
.TPx
.REQ .msoquiet "file"
As
.request .mso ,
but no warning is emitted if
.I file
does not exist.
.
.
.TPx
.REQ .na
Disable output line adjustment.
.
.
.TPx
.REQ .ne
Need a one-line vertical space.
.
.TPx
.REQ .ne "N"
Need
.I N
vertical space (default scaling indicator\~\c
.scaleindicator v ).
.
.
.TPx
.REQ .nf
Disable filling of output lines;
a pending output line is broken.
.
Clears
.BR \[rs]n[.u] .
.
.
.TPx
.REQ .nh
Disable automatic hyphenation;
same as
.RB \[lq] ".hy 0" \[rq].
.
.TPx
.REQ .nm
Number mode off.
.
.TPx
.REQ .nm "\[+-]N \fR[\fPM \fR[\fPS \fR[\fPI\fR]]]\fP"
In line number mode, set number, multiple, spacing, and indentation.
.
.TPx
.REQ .nn
Do not number next line.
.
.TPx
.REQ .nn "N"
Do not number next
.I N
lines.
.
.
.TPx
.REQ .nop "anything"
Interpret
.I anything
as if it were an input line.
.
.
.TPx
.REQ .nr "register \[+-]N \fR[\fPM\fR]\fP"
Define or modify
.I register
using
.I \[+-]N
with auto-increment
.IR M .
.
.TPx
.REQ .nroff
Make the built-in conditions
.B n
true and
.B t
false.
.
.TPx
.REQ .ns
Turn on no-space mode.
.
.TPx
.REQ .nx
Immediately jump to end of current file.
.
.TPx
.REQ .nx "filename"
Immediately continue processing with file
.IR file .
.
.TPx
.REQ .open "stream filename"
Open
.I filename
for writing and associate the stream named
.I stream
with it.
.
.TPx
.REQ .opena "stream filename"
Like
.request .open
but append to it.
.
.TPx
.REQ .os
Output vertical distance that was saved by the
.request .sv
request.
.
.TPx
.REQ .output "string"
Emit
.I string
directly to intermediate output, allowing leading whitespace if
.I string
starts with
\&\f[CB]\[dq]\f[]
(which is stripped off).
.
.TPx
.REQ .pc
Reset page number character to\~\c
.squoted_char % .
.
.TPx
.REQ .pc "c"
Page number character.
.
.
.TPx
.REQ .pev
Report the state of the current environment followed by that of all
other environments to the standard error stream.
.
.
.TPx
.REQ .pi "program"
Pipe output to
.I program
(nroff only).
.
.TPx
.REQ .pl
Set page length to default
.scalednumber 11 i .
The current page length is stored in register
.BR .p .
.
.TPx
.REQ .pl "\[+-]N"
Change page length to
.I \[+-]N
(default scaling indicator\~\c
.scaleindicator v ).
.
.TPx
.REQ .pm
Report,
to the standard error stream,
the names and sizes in bytes of
defined
macros,
strings,
and
diversions.
.
.TPx
.REQ .pn "\[+-]N"
Next page number
.IR N .
.
.TPx
.REQ .pnr
Print the names and contents of all currently defined number registers
on stderr.
.
.TPx
.REQ .po
Change to previous page offset.
.
The current page offset is available in register
.BR .o .
.
.TPx
.REQ .po "\[+-]N"
Page offset
.IR N .
.
.TPx
.REQ .ps
Return to previous point size.
.TPx
.
.REQ .ps "\[+-]N"
Set/increase/decrease the point size to/by
.I N
scaled points
(a non-positive resulting point size is set to 1\~u);
also see
.esc[] s \[+-]N .
.
.TPx
.REQ .psbb "filename"
Get the bounding box of a PostScript image
.IR filename .
.
.TPx
.REQ .pso "command"
This behaves like the
.request .so
request except that input comes from the standard output of
.IR command .
.
.
.TPx
.REQ .ptr
Report names and positions of all page location traps to the standard
error stream.
.
.
.TPx
.REQ .pvs
Change to previous post-vertical line spacing.
.
.TPx
.REQ .pvs "\[+-]N"
Change post-vertical line spacing according to
.I \[+-]N
(default scaling indicator\~\c
.scaleindicator p ).
.
.TPx
.REQ .rchar "c1 c2 \fR\&.\|.\|.\&\fP"
Remove the definitions of entities
.IR c1 ,
.IR c2 ,
\&.\|.\|.\&
.
.TPx
.REQ .rd "prompt"
Read insertion.
.
.TPx
.REQ .return
Return from a macro.
.
.TPx
.REQ .return "anything"
Return twice, namely from the macro at the current level and from the
macro one level higher.
.
.TPx
.REQ .rfschar "f c1 c2 \fR\&.\|.\|.\&\fP"
Remove the font-specific definitions of glyphs
.IR c1 ,
.IR c2 ,
\&.\|.\|.\& for
.RI font\~ f .
.
.TPx
.REQ .rj "n"
Right justify the next
.I n
input lines.
.
.TPx
.REQ .rm "name"
Remove request, macro, diversion, or string
.IR name .
.
.TPx
.REQ .rn "old new"
Rename request, macro, diversion, or string
.I old
to
.IR new .
.
.TPx
.REQ .rnn "reg1 reg2"
Rename register
.I reg1
to
.IR reg2 .
.
.TPx
.REQ .rr "ident"
Remove name of number register
.IR ident .
.
.TPx
.REQ .rs
Restore spacing; turn no-space mode off.
.
.TPx
.REQ .rt
Return
.I (upward only)
to vertical position marked by
.B .mk
on the current page.
.
.TPx
.REQ .rt "\[+-]N"
Return
.I (upward only)
to specified distance from the top of the page (default scaling
indicator\~\c
.scaleindicator v ).
.
.TPx
.REQ .schar "c anything"
Define global fallback character (or glyph)\~\c
.I c
as string
.IR anything .
.
.
.TPx
.REQ .shc
Reset the soft hyphen glyph to
.esc [hy] .
.
.
.TPx
.REQ .shc c
Set the soft hyphen glyph
.RI to\~ c .
.
.
.TPx
.REQ .shift "n"
In a macro, shift the arguments by
.IR n \~\c
positions.
.
.TPx
.REQ .sizes "s1 s2 \fR\&.\|.\|.\&\fP s\fRn\~\c
[\f[CB]0\f[]]
Set available font sizes similar to the
.B sizes
command in a
.I DESC
file.
.
.
.TPx
.REQ .so file
Replace the request's control line with the contents of
.IR file ,
\[lq]sourcing\[rq] it.
.
.
.TPx
.REQ .soquiet file
As
.request .so ,
but no warning is emitted if
.I file
does not exist.
.
.
.TPx
.REQ .sp
Skip one line vertically.
.
.TPx
.REQ .sp "N"
Space vertical distance
.I N
up or down according to sign of
.I N
(default scaling indicator\~\c
.scaleindicator v ).
.
.TPx
.REQ .special
Reset global list of special fonts to be empty.
.
.TPx
.REQ .special "s1 s2 \fR\&.\|.\|.\&\fR"
Fonts
.IR s1 ,
.IR s2 ,
etc.\& are special and are searched for glyphs not in the
current font.
.
.TPx
.REQ .spreadwarn
Toggle the spread warning on and off (the default) without changing its
value.
.
.TPx
.REQ .spreadwarn N
Emit a
.B break
warning if the additional space inserted for each space between words in
an output line adjusted to both margins is larger than or equal to
.IR N .
.
A negative
.I N
is treated as 0.
.
The default scaling indicator is\~\c
.scaleindicator m .
.
At startup,
.request .spreadwarn
is inactive and
.I N
is
.scalednumber "3 m" .
.
.TPx
.REQ .ss N
Set minimal inter-word spacing to
.IR N \~12ths
of the space width of the current font.
.
.TPx
.REQ .ss "N M"
As
.B .ss\~\c
.IR N ,
and set additional inter-sentence spacing to
.IR M \~12ths
of the space width of the current font.
.
.TPx
.REQ .stringdown stringvar
Replace each byte in the string named
.I stringvar
with its lowercase version.
.
.TPx
.REQ .stringup stringvar
Replace each byte in the string named
.I stringvar
with its uppercase version.
.
.TPx
.REQ .sty "n style"
Associate
.I style
with font position
.IR n .
.
.TPx
.REQ .substring "str start \fR[\fPend\fR]\fP"
Replace the string named
.I str
with its substring bounded by the indices
.I start
and
.IR end ,
inclusive.
.
Negative indices count backwards from the end of the string.
.
.
.TPx
.REQ .sv
Save
.scalednumber "1 v"
of vertical space.
.TPx
.REQ .sv "N"
Save the vertical distance
.I N
for later output with
.request .os
request (default scaling indicator\~\c
.scaleindicator v ).
.
.TPx
.REQ .sy "command-line"
Execute program
.IR command-line .
.
.
.TPx
.REQ .ta "n1 n2 \fR\&.\|.\|.\&\fP n\fRn\fP \f[CB]T\f[] r1 r2 \
\fR\&.\|.\|.\&\fP r\fRn\fP"
Set tabs at positions
.IR n1 ,
.IR n2 ,
\&.\|.\|.\&,
.IR n n,
then set tabs at
.IR n n+ m \[tmu] r n+ r1
through
.IR n n+ m \[tmu] r n+ r n,
where
.I m
increments from 0,
1,
2,
\&.\|.\|.\& to the output line length.
.
Each
.IR n \~argument
can be prefixed with
.RB a\~\[lq] + \[rq]
to place the tab stop
.I ni
at a distance relative to the previous,
.IR n ( i \-1).
.
Each argument
.IR ni \~or\~ ri
can be suffixed with a letter to align text within the tab column
bounded by tab stops
.IR i \~and\~ i +1;
.RB \[lq] L \[rq]
for left-aligned
(the default),
.RB \[lq] C \[rq]
for centered,
and
.RB \[lq] R \[rq]
for right-aligned.
.
.
.TPx
.REQ .tc
Remove tab repetition glyph.
.
.
.TPx
.REQ .tc "c"
Set tab repetition glyph
.RI to\~ c
(default: none).
.
.
.TPx
.REQ .ti "\[+-]N"
Temporary indent next line (default scaling indicator\~\c
.scaleindicator m ).
.
.TPx
.REQ .tkf "font s1 n1 s2 n2"
Enable track kerning for
.IR font .
.
.TPx
.REQ .tl "\f[CB]\[aq]\f[]left\f[CB]\[aq]\f[]center\f[CB]\[aq]\f[]right\
\f[CB]\[aq]\f[]"
Three-part title.
.
.TPx
.REQ .tm "anything"
Print
.I anything
on stderr.
.
.TPx
.REQ .tm1 "anything"
Print
.I anything
on stderr, allowing leading whitespace if
.I anything
starts with
\&\f[CB]\[dq]\f[]
(which is stripped off).
.
.TPx
.REQ .tmc "anything"
Similar to
.request .tm1
without emitting a final newline.
.
.TPx
.REQ .tr "abcd\fR\&.\|.\|.\&\fP"
Translate
.I a
to
.IR b ,
.I c
to
.IR d ,
etc.\& on output.
.
.TPx
.REQ .trf "filename"
Transparently output the contents of file
.IR filename .
.
.TPx
.REQ .trin "abcd\fR\&.\|.\|.\&\fP"
This is the same as the
.request .tr
request except that the
.B asciify
request uses the character code (if any) before the character
translation.
.
.TPx
.REQ .trnt "abcd\fR\&.\|.\|.\&\fP"
This is the same as the
.request .tr
request except that the translations do not apply to text that is
transparently throughput into a diversion with
.esc ! .
.
.TPx
.REQ .troff
Make the built-in conditions
.B t
true and
.B n
false.
.
.TPx
.REQ .uf "font"
Set underline font to
.I font
(to be switched to by
.request .ul ).
.
.TPx
.REQ .ul "N"
Underline
(italicize in
.I troff
mode)
.I N
input lines.
.
.TPx
.REQ .unformat "diversion"
Unformat space characters and tabs in
.IR diversion ,
preserving font information.
.
.
.TPx
.REQ .vpt
Enable vertical position traps.
.
.
.TPx
.REQ .vpt\~0
Disable vertical position traps.
.
.
.TPx
.REQ .vs
Change to previous vertical base line spacing.
.
.TPx
.REQ .vs "\[+-]N"
Set vertical base line spacing to
.I \[+-]N
(default scaling indicator\~\c
.scaleindicator p ).
.
.TPx
.REQ .warn
Enable all warnings.
.
.TPx
.REQ .warn "n"
Set warnings code to
.IR n .
.
.TPx
.REQ .warnscale "si"
Set scaling indicator used in warnings to
.IR si .
.
.
.TPx
.REQ .wh N
Remove active trap at vertical position
.IR N ;
a negative value is measured upward from page bottom.
.
.
.TPx
.REQ .wh "N name"
Plant trap,
calling macro
.I name
when page location
.I N
is reached or passed;
a negative value is measured upward from page bottom.
.
Any active trap already present at
.I N
is replaced.
.
.
.TPx
.REQ .while "cond-expr anything"
Evaluate
.IR cond-expr ,
and repeatedly execute
.I anything
unless and until
.I cond-expr
evaluates false.
.
.
.TPx
.REQ .write "stream anything"
Write
.I anything
to the stream named
.IR stream .
.
.TPx
.REQ .writec "stream anything"
Similar to
.request .write
without emitting a final newline.
.
.TPx
.REQ .writem "stream xx"
Write contents of macro or string
.I xx
to the stream named
.IR stream .
.
.PD
.
.
.P
Besides these standard groff requests, there might be further macro
calls.
They can originate from a macro package (see
.BR roff (@MAN7EXT@)
for an overview) or from a preprocessor.
.
.
.P
Preprocessor macros are easy to recognize.
.
They enclose their code between a pair of characteristic macros.
.
.
.P
.TS
box, center, tab (^);
c | c | c
CfCB | CfCB | CfCB.
preprocessor^start macro^ end macro
=
@g@chem^.cstart^.cend
@g@eqn^.EQ^.EN
grap^.G1^.G2
@g@grn^.GS^.GE
.\" Keep the .IF line below the @g@ideal line.
@g@ideal^.IS^.IE
^^.IF
@g@pic^.PS^.PE
@g@refer^.R1^.R2
@g@soelim^\f[I]none^\f[I]none
@g@tbl^.TS^.TE
_
glilypond^.lilypond start^.lilypond stop
gperl^.Perl start^.Perl stop
gpinyin^.pinyin start^.pinyin stop
.TE
.
.
.P
The \%\[oq]@g@ideal\[cq] preprocessor is not available in
.I groff
yet.
.
.
.\" ====================================================================
.SH "Escape sequences"
.\" ====================================================================
.
Whereas requests must occur on control lines,
escape sequences can occur intermixed with text and appear in arguments
to requests and macros
(and sometimes other escape sequences).
.
An escape sequence
(or simply \[lq]escape\[rq])
is introduced by the escape character,
a backslash
.RB \[lq] \[rs] \[rq]
(but see the
.B .ec
request).
.
The next character identifies the escape's function.
.
Escapes vary in length.
.
Some take an argument,
and of those,
some have different syntactical forms for a one-character,
two-character,
or arbitrary-length argument.
.
Others accept only an arbitrary-length argument.
.
In the former convention,
a one-character argument follows the function character immediately,
an opening parenthesis
.RB \[lq] ( \[rq]
introduces a two-character argument
(no closing parenthesis is used),
and an argument of arbitrary length is enclosed in brackets
.RB \[lq] [] \[rq].
.
In the latter convention,
the user selects a delimiter character;
the neutral apostrophe
.RB \[lq] \[aq] \[rq]
is a popular choice and shown in this document.
.
Some characters cannot be used as delimiters;
see section \[lq]Escapes\[rq] in the
.I groff
Texinfo manual for details.
.
A few escapes are idiosyncratic,
and support both of the foregoing conventions
.RB (\[lq] \[rs]s \[rq]),
designate their own terminating character
.RB (\[lq] \[rs]? \[rq]),
consume input until the next newline
.RB (\[lq] \[rs]! \[rq],
.RB \[lq] \[rs]" \[rq],
.RB \[lq] \[rs]# \[rq]),
or support an additional modifier character
.RB (\[lq] \[rs]s \[rq]
again).
.
.
.P
Escape sequences serve a variety of purposes.
.
Widespread uses include
commenting the source document;
changing the font style;
setting the point size;
interpolating special characters,
number registers,
and strings into the text;
and placing or suppressing break and hyphenation points.
.
As with requests,
use of escapes in source documents may interact poorly with a macro
package you use;
consult its documentation to learn of \[lq]safe\[rq] escapes or
alternative facilities it provides to achieve the desired result.
.
.
.P
If the escape character is followed by a character that does not
identify a defined operation,
the escape character is ignored
(producing a diagnostic of the \[lq]escape\[rq] warning type,
which is not enabled by default)
and the following character is processed normally.
.
.
.\" ====================================================================
.SS "Escape short reference"
.\" ====================================================================
.
The escape sequences
.esc \[dq] ,
.esc # ,
.esc $ ,
.esc * ,
.esc a ,
.esc e ,
.esc n ,
.esc t ,
.esc g ,
.esc V ,
and
.escarg \& newline
are interpreted even in copy mode.
.
.
.P
.PD 0
.
.\" ========= comments =========
.
.TP
.ESC \[dq]
Comment.
.
Everything up to the end of the line is ignored.
.
.
.TP
.ESC #
Comment.
.
Everything up to and including the next newline is ignored.
.
.
.\" ========= strings =========
.
.TP
.ESC * s
Interpolate string with one-character
.RI name\~ s .
.
.
.TP
.ESC *( st
Interpolate string with two-character
.RI name\~ st .
.
.
.TP
.ESC[] * string
Interpolate string with name
.I string
(of arbitrary length).
.
.
.TP
.ESC[] * "string arg1 arg2 \fR\&.\|.\|.\fP"
Interpolate string with name
.I string
(of arbitrary length),
taking
.IR arg1 ,
.IR arg2 ,
\&.\|.\|.\&
as arguments.
.
.
.\" ========= macro arguments =========
.
.TP
.ESC $0
Interpolate name by which currently-executing macro was invoked.
.
.
.TP
.ESC $ n
Interpolate macro or string parameter
.RI numbered\~ n
.RI (1\|\[<=]\| n \|\[<=]\|9).
.
.
.TP
.ESC $( nn
Interpolate macro or string parameter
.RI numbered\~ nn
.RI (01\|\[<=]\| nn \|\[<=]\|99).
.
.TP
.ESC[] $ nnn
Interpolate macro or string parameter
.RI numbered\~ nnn
.RI ( nnn \|\[>=]\|1).
.
.
.TP
.ESC $*
Interpolate concatenation of all macro or string parameters,
separated by spaces.
.
.
.TP
.ESC $@
Interpolate concatenation of all macro or string parameters,
with each surrounded by double quotes and separated by spaces.
.
.
.TP
.ESC $\[ha]
Interpolate concatenation of all macro or string parameters
as if they were arguments to the
.request .ds
request.
.
.
.\" ========= escaped characters =========
.
.
.TP
.ESC \[aq]
Translates to
.esc [aa] ,
the acute accent special character.
.
.
.TP
.ESC \[ga]
Translates to
.esc [ga] ,
the grave accent special character.
.
.
.TP
.ESC \-
Translates to
.esc [\-] ,
the minus sign special character.
.
.
.TP
.ESC _
Translates to
.esc [ul] ,
the underline special character.
.
.
.TP
.ESC %
Control hyphenation.
.
.
.TP
.ESC !
Transparent line.
.
The remainder of the input line is interpreted
(1) when the current diversion is read;
or
(2) if in the top-level diversion,
by the output driver.
.
.
.TP
.ESC? anything
Transparently embed
.IR anything ,
read in copy mode,
in a diversion.
.
.
.\" ========= spacing [sic; \& and \) don't really space] =========
.
.TP
.ESC \& space
Unbreakable,
non-adjustable word space.
.
.
.TP
.ESC \[ti]
Unbreakable,
adjustable space.
.
.
.TP
.ESC 0
Unbreakable digit-width space.
.
.
.TP
.ESC |
Unbreakable 1/6\~em (\[lq]thin\[rq]) space glyph;
zero-width in
.IR nroff .
.
.
.TP
.ESC \[ha]
Unbreakable 1/12\~em (\[lq]hair\[rq]) space glyph;
zero-width in
.IR nroff .
.
.
.TP
.ESC &
Non-printing input break.
.
.
.TP
.ESC )
Non-printing input break,
transparent to end-of-sentence recognition.
.
.
.TP
.ESC /
Apply italic correction.
.
Use between an immediately adjacent oblique glyph on the left and an
upright glyph on the right.
.
.
.TP
.ESC ,
Apply left italic correction.
.
Use between an immediately adjacent upright glyph on the left and an
oblique glyph on the right.
.
.
.TP
.ESC :
Non-printing break point
(similar to
.esc % ,
but never produces a hyphen glyph).
.
.
.TP
.ESC "" newline
Continue current input line on the next.
.
.
.\" ========= structuring =========
.
.TP
.ESC {
Begin conditional input.
.
.TP
.ESC }
End conditional input.
.
.\" ========= longer escape names =========
.
.TP
.ESC ( gl
Interpolate glyph with two-character name
.IR gl .
.
.
.TP
.ESC[] "" glyph
Interpolate glyph with name
.I glyph
(of arbitrary length).
.
.
.TP
.ESC[] "" "base-glyph comp1 comp2 \fR\&.\|.\|."
Interpolate composite glyph constructed from
.I base-glyph
and components
.IR comp1 ,
.IR comp2 ,
and so on.
.
.
.TP
.ESC[] "" "\f[CB]char\f[]nnn"
Interpolate glyph of eight-bit encoded character
.IR nnn ,
where
.RI 0\|\[<=]\| nnn \|\[<=]\|255.
.
.
.TP
.ESC[] "" "\f[CB]u\f[]nnnn\f[R][\f[]n\f[R][\f[]n\f[R]]]"
Interpolate glyph of Unicode character with code point
.IR nnnn [ n [ n ]]
in uppercase hexadecimal.
.
.
.TP
.ESC[] "" "\f[CB]u\f[]base-glyph\f[R][\f[]\f[CB]_\f[]\
combining-component\f[R]].\|.\|."
Interpolate composite glyph from Unicode character
.I base-glyph
and
.IR combining-components .
.
.
.\" ========= alphabetical escapes =========
.
.TP
.ESC a
In copy mode,
interpolate leader character.
.
.
.TP
.ESCq A anything
Interpolate 1 if
.I anything
is an acceptable identifier for a string,
macro,
diversion,
register,
environment,
or font,
and\~0 otherwise.
.
.
.TP
.ESCq b abc\fR\&.\|.\|.\&\fP
Build bracket:
stack glyphs
.IR a ,
.IR b ,
.IR c .\|.\|.\&
vertically.
.
.
.TP
.ESCq B anything
Interpolate 1 if
.I anything
is a valid numeric expression,
and\~0 otherwise.
.
.
.TP
.ESC c
Continue output line at next input line.
.
.
.TP
.ESCq C glyph
As
.esc[] "" glyph ,
but compatible with other
.I troff \" generic
implementations.
.
.
.TP
.ESC d
Move downward \[12]\~vee
(\[12]\~line in
.IR nroff ).
.
.
.TP
.ESCq D anything
Send
.I anything
to the output device as a drawing command;
see
.IR groff_out (@MAN5EXT@).
.
.
.TP
.ESC e
Interpolate escape character.
.
.
.TP
.ESC E
As
.esc e ,
but not interpreted in copy mode.
.
.
.TP
.ESC f F
Change to font or style with one-character name or one-digit
.RI position\~ F .
.
.
.TP
.ESC fP
Switch to previous font or style.
.
.
.TP
.ESC f( ft
Change to font with two-character name or two-digit
.RI position\~ ft .
.
.
.TP
.ESC[] f font
Change to font with arbitrarily long name or position
.IR font .
.
.
.TP
.ESC[] f ""
Switch to previous font or style.
.
.
.TP
.ESC F f
Change to font family with one-character
.RI name\~ f .
.
.
.TP
.ESC F( fm
Change to font family with two-character
.RI name\~ fm .
.
.
.TP
.ESC[] F fam
Change to font family with arbitrarily long name
.IR fam .
.
.
.TP
.ESC[] F ""
Switch to previous font family.
.
.
.TP
.ESC g r
Interpolate format of register with one-character
.RI name\~ r .
.
.
.TP
.ESC g( rg
Interpolate format of register with two-character
.RI name\~ rg .
.IR rg .
.
.
.TP
.ESC[] g reg
Interpolate format of register with arbitrarily long name
.IR reg .
.
.
.TP
.ESCq h N
Horizontally move
.IR N \~ens
(or specified units)
right
(left if negative).
.
.
.TP
.ESCq H N
Set height of current font to
.IR N \~scaled points
(or specified units).
.
.
.TP
.ESC k r
Mark horizontal position in one-character register
.RI name\~ r .
.
.TP
.ESC k( rg
Mark horizontal position in two-character register
.RI name\~ rg .
.
.
.TP
.ESC[] k reg
Mark horizontal position in register with arbitrarily long
.RI name\~ reg .
.
.
.TP
.ESCq l N\f[R][\f[]g\f[R]]
Draw horizontal line of length
.IR N \~ems
(or specified units),
optionally using
.RI glyph\~ g .
.
.
.TP
.ESCq L N\f[R][\f[]g\f[R]]
Draw vertical line of length
.IR N \~vees
(or specified units),
optionally using
.RI glyph\~ g .
.
.
.TP
.ESC m c
Change drawing color to that with one-character
.RI name\~ c .
.
.
.TP
.ESC m( cl
Change drawing color to that with two-character
.RI name\~ cl .
.
.
.TP
.ESC[] m color
Change drawing color to that with arbitrarily long
.RI name\~ color .
.
.
.TP
.ESC[] m ""
Switch to previous drawing color.
.
.
.TP
.ESC M c
Change fill color to that with one-character
.RI name\~ c .
.
.
.TP
.ESC M( cl
Change fill color to that with two-character
.RI name\~ cl .
.
.
.TP
.ESC[] M color
Change fill color to that with arbitrarily long
.RI name\~ color .
.
.
.TP
.ESC[] M ""
Switch to previous fill color.
.
.
.TP
.ESC n r
Interpolate value stored in register with one-character
.RI name\~ r .
.
.
.TP
.ESC n( rg
Interpolate value stored in register with two-character
.RI name\~ rg .
.
.
.TP
.ESC[] n reg
Interpolate value stored in register with arbitrarily long
.RI name\~ reg .
.
.
.TP
.ESCq N n
Interpolate glyph with
.RI index\~ n
in the current font.
.
.
.TP
.ESCq o abc\fR\&.\|.\|.\&\fP
Overstrike glyphs
.IR a ,
.IR b ,
.IR c ,
and so on.
.
.
.TP
.ESC O0
At the outermost suppression level,
disable glyph emission to the output driver.
.
.
.TP
.ESC O1
At the outermost suppression level,
enable glyph emission to the output driver.
.
.
.TP
.ESC O2
At the outermost suppression level,
enable glyph emission to the output driver and write to the standard
error stream the page number and four bounding box registers enclosing
glyphs written since the previous
.B \[rs]O
escape sequence.
.
.
.TP
.ESC O3
Begin a nested suppression level.
.
.
.TP
.ESC O4
End a nested suppression level.
.
.
.TP
.ESC[] O "\f[CB]5\f[]Pfilename"
At the outermost suppression level,
write
.I filename
to the standard error stream;
.IR P \~indicates
the position of an image and must be one of
.BR l ,
.BR r ,
.BR c ,
or
.B i
(left,
right,
centered,
inline).
.
.
.TP
.ESC p
Break output line at next word boundary;
adjust if applicable.
.
.
.TP
.ESC r
Move \[lq]in reverse\[rq] (upward) 1\~vee
(reverse linefeed in
.IR nroff ).
.
.
.TP
.ESCq R "name\~\[+-]N"
Set,
increment,
or decrement register
.I name
.RI by\~ N .
.
.
.TP
.ESC s \[+-]N
Set/increase/decrease the point size to/by
.I N
scaled points.
.
.I N
must be a single digit;
0 restores the previous point size.
.
(In compatibility mode only,
a non-zero
.I N
must be in the range 4\[en]39.)
.
Otherwise,
as
.request .ps
request.
.
.
.TP
.ESC s( \[+-]N
.TQ
.fam C
.BI \es \[+-] ( N
.fam
Set/increase/decrease the point size to/by
.I N
scaled points;
.I N
is a two-digit number \[>=]1.
.
As
.request .ps
request.
.
.
.TP
.ESC[] s \[+-]N
.TQ
.fam C
.BI \es \[+-] [ N ]
.fam
.TQ
.ESCq s \[+-]N
.TQ
.fam C
.BI \es \[+-] \[aq] N \[aq]
.fam
Set/increase/decrease the point size to/by
.I N
scaled points.
.
As
.request .ps
request.
.
.
.TP
.ESCq S N
Slant output glyphs by
.I N
degrees;
the direction of text flow is positive.
.
.
.TP
.ESC t
In copy mode,
interpolate tab character.
.
.
.TP
.ESC u
Move upward \[12]\~vee
(\[12]\~line in
.IR nroff ).
.
.
.TP
.ESCq v N
Vertically move
.IR N \~vees
(or specified units)
down
(up if negative).
.
.
.TP
.ESC V e
Interpolate contents of environment variable with one-character
.RI name\~ e .
.
.
.TP
.ESC V( ev
Interpolate contents of environment variable with two-character
.RI name\~ ev .
.
.
.TP
.ESC[] V env
Interpolate contents of environment variable with arbitrarily long
.RI name\~ env .
.
.
.TP
.ESCq w anything
Interpolate width of
.IR anything ,
formatted in a dummy environment.
.
.
.TP
.ESCq x N
Increase required line space by
.IR N \~vees
(or specified units;
negative before,
positive after).
.
.
.TP
.ESCq X anything
Send
.I anything
to the output device as a control command;
see
.IR groff_out (@MAN5EXT@).
.
.
.TP
.ESC Y n
Send interpolation of string or macro with one-character
.RI name\~ n
to the output device as a control command.
.
.
.TP
.ESC Y( nm
Send interpolation of string or macro with two-character
.RI name\~ nm
to the output device as a control command.
.
.
.TP
.ESC[] Y name
Send interpolation of string or macro with arbitrarily long
.RI name\~ name
to the output device as a control command.
.
.
.TP
.ESC z c
Output glyph
.I c
without advancing the print position,
as if it were zero-width.
.
.
.TP
.ESCq Z anything
Print
.I anything
and then restore the horizontal and vertical position;
.I anything
must not contain tabs or leaders.
.
.PD
.
.
.\" ====================================================================
.SH Identifiers
.\" ====================================================================
.
An identifier is a label for an object of syntactical importance like
a register,
a name
(macro,
string,
or diversion),
an environment,
a font,
a style,
or a glyph,
comprising a sequence of one or more characters with the following
exceptions.
.
.
.IP \[bu]
Spaces,
tabs,
or newlines.
.
.
.IP \[bu]
Invalid input characters;
these are certain control characters
(from the sets \[lq]C0 Controls\[rq] and \[lq]C1 Controls\[rq] as
Unicode describes them).
.
When
.I \%@g@troff
encounters one in an identifier,
it produces a warning diagnostic of type
.RB \[lq] input \[rq]
(see section \[lq]Warnings\[rq] in
.IR \%@g@troff (@MAN1EXT@)).
.
.
.IP
On a machine using the ISO 646,
8859,
or 10646 character encodings,
invalid input characters are
.BR 0x00 ,
.BR 0x08 ,
.BR 0x0B ,
.BR 0x0D \[en] 0x1F ,
and
.BR 0x80 \[en] 0x9F .
.
.
.IP
On an EBCDIC host,
they are
.BR 0x00 \[en] 0x01 ,
.BR 0x08 ,
.BR 0x09 ,
.BR 0x0B ,
.BR 0x0D \[en] 0x14 ,
.BR 0x17 \[en] 0x1F ,
and
.BR 0x30 \[en] 0x3F .
.
.
.IP
Some of these code points are used by
.I \%@g@troff
internally,
making it non-trivial to extend the program to cover Unicode or other
character encodings that use characters from these ranges.
.
(Consider what happens when a C1 control
.BR 0x80 \[en] 0x9F
is necessary as a continuation byte in a UTF-8 sequence.}
.
.
.IP
Invalid characters are removed during parsing;
an identifier
.RB \[lq] foo \[rq],
followed by an invalid character,
followed by
.RB \[lq] bar \[rq]
is treated as
.RB \[lq] foobar \[rq] .
.
.
.\" ====================================================================
.SH Strings
.\" ====================================================================
.
.I groff
has string variables primarily for user convenience.
.
Only one string is predefined by the language.
.
.
.TPx
.STRING .T
Contains the name of the output driver
(for example,
.RB \[lq] utf8 \[rq]
or
.RB \[lq] pdf \[rq] ).
.
.
.P
The
.request .ds
request creates a string with a specified name and contents
and the
.esc *
escape dereferences its name,
retrieving the contents.
.
Dereferencing an undefined string name defines it as empty.
.
.
.P
The
.request .as
request is similar to
.request .ds
but appends to a string instead of redefining it.
.
If
.request .as
is called with only one argument,
no operation is performed
(beyond dereferencing it).
.
.
.P
The
.request .ds1
request defines a string such that compatibility mode is off when the
string is later interpolated.
.
To be more precise,
a
.I compatibility save
input token is inserted at the beginning of the string,
and a
.I compatibility restore
input token at the end.
.
Likewise,
the
.request .as1
request is similar to
.BR .as ,
but compatibility mode is switched off when the appended portion of the
string is later interpolated.
.
.
.P
.B Caution:
Unlike other requests,
the second argument to these requests consumes the remainder of the
input line,
including trailing spaces.
.
It is good style to end string definitions
(and appendments)
with a comment,
even an empty one,
to prevent unwanted space from creeping into them during source document
maintenance.
.
.
.P
To store leading space in a string,
start it with a double quote.
.
A double quote is special only in that position;
double quotes in any other location are included in the string
(the effects of escape sequences notwithstanding).
.
.
.P
Strings,
macros,
and diversions share a name space.
.
Internally,
the same mechanism is used to store them.
.
.
.P
Several requests exist to perform rudimentary string operations.
.
Strings can be queried
(\c
.request .length )
and modified
(\c
.request .chop ,
.request .substring ,
.request .stringup ,
.request .stringdown ),
and their names can be manipulated through renaming,
removal,
and aliasing
(\c
.request .rn ,
.request .rm ,
.request .als).
.
.
.\" ====================================================================
.SH Registers
.\" ====================================================================
.
Registers are variables that store a value.
.
In groff,
most registers store numerical values
(see section \[lq]Numerical Expressions\[rq] above),
but some can also hold a string value.
.
.
.P
Each register is given a name.
Arbitrary registers can be defined and set with the
.request .nr
request.
.
.
.P
The value stored in a register can be retrieved by the escape sequences
introduced by
.esc n .
.
.
.P
Most useful are predefined registers.
.
In the following the notation
.I name
is used to refer to
.register name
to make clear that we speak about registers.
.
Please keep in mind that the
.esc[] n ""
decoration is not part of the register name.
.
.
.\" ====================================================================
.SS "Read-only registers"
.\" ====================================================================
.
The following registers have predefined values that should not be
modified by the user (usually, registers starting with a dot are
read-only).
.
Mostly, they provide information on the current settings or store
results from request calls.
.
.
.P
.PD 0
.
.TPx
.REG $$
The process ID of
.BR troff .
.
.TPx
.REG .$
Number of arguments in the current macro or string.
.
.TPx
.REG .a
Post-line extra line-space most recently utilized using
.esc x .
.
.TPx
.REG .A
Set to\~1 in
.B troff
if option
.option \-A
is used; always\~1 in
.BR nroff .
.
.TPx
.REG .b
The emboldening offset while
.request .bd
is active.
.
.TPx
.REG .br
Within a macro, set to\~1 if macro called with the \[oq]normal\[cq]
control character, and to\~0 otherwise.
.
.TPx
.REG .c
Current input line number.
.
.TPx
.REG .C
1\~if compatibility mode is in effect, 0\~otherwise.
.
Always\~0 in a
.request .do
request;
see
.register .cp
below.
.
.TPx
.REG .cdp
The depth of the last glyph added to the current environment.
.
It is positive if the glyph extends below the baseline.
.
.TPx
.REG .ce
The number of lines remaining to be centered, as set by the
.request .ce
request.
.
.TPx
.REG .cht
The height of the last glyph added to the current environment.
.
It is positive if the glyph extends above the baseline.
.
.TPx
.REG .color
1\~if colors are enabled, 0\~otherwise.
.
.TPx
.REG .cp
Within a
.request .do
request,
the saved value of compatibility mode (see
.register .C
above).
.
.TPx
.REG .csk
The skew of the last glyph added to the current environment.
.
The skew of a glyph is how far to the right of the center of a glyph
the center of an accent over that glyph should be placed.
.
.TPx
.REG .d
Current vertical place in current diversion; equal to register
.BR nl .
.
.TPx
.REG .ev
The name or number of the current environment (string-valued).
.
.TPx
.REG .f
Current font number.
.
.TPx
.REG .F
The name of the current input file (string-valued).
.
.TPx
.REG .fam
The current font family (string-valued).
.
.TPx
.REG .fn
The current (internal) real font name (string-valued).
.
.TPx
.REG .fp
The number of the next free font position.
.
.
.TPx
.REG .g
Always 1 in GNU
.IR troff . \" GNU
.
Use to test if running under
.IR groff .
.
.
.TPx
.REG .h
Text baseline high-water mark on page or in diversion.
.
.
.TPx
.REG .H
Number of basic units per horizontal unit of output device resolution.
.
.TPx
.REG .height
The current font height as set with
.esc H .
.
.TPx
.REG .hla
The hyphenation language in the current environment.
.
.TPx
.REG .hlc
The count of immediately preceding consecutive hyphenated lines in the
current environment.
.
.TPx
.REG .hlm
The maximum number of consecutive hyphenated lines allowed in the
current environment.
.
.TPx
.REG .hy
The automatic hyphenation mode in the current environment.
.
.TPx
.REG .hym
The hyphenation margin in the current environment.
.
.TPx
.REG .hys
The hyphenation space adjustment threshold in the current environment.
.
.TPx
.REG .i
Current indentation.
.
.TPx
.REG .in
The indentation that applies to the current output line.
.
.TPx
.REG .int
Positive if last output line contains
.esc c .
.
.
.TPx
.REG .j
Adjustment mode encoded as an integer.
.
Do not interpret or perform arithmetic on its value.
.
.
.TPx
.REG .k
The current horizontal output position (relative to the current
indentation).
.
.
.TPx
.REG .kern
1\~if pairwise kerning is enabled, 0\~otherwise.
.
.TPx
.REG .l
Current line length.
.
.TPx
.REG .L
The current line spacing setting as set by
.request .ls .
.
.TPx
.REG .lg
The current ligature mode (as set by the
.request .lg
request).
.
.TPx
.REG .linetabs
The current line-tabs mode (as set by the
.request .linetabs
request).
.
.TPx
.REG .ll
The line length that applies to the current output line.
.
.TPx
.REG .lt
The title length (as set by the
.request .lt
request).
.
.TPx
.REG .m
The current drawing color (string-valued).
.
.TPx
.REG .M
The current background color (string-valued).
.
.TPx
.REG .n
Length of text portion on previous output line.
.
.TPx
.REG .ne
The amount of space that was needed in the last
.request .ne
request that caused a trap to be sprung.
.
Useful in conjunction with register
.BR .trunc .
.
.
.TPx
.REG .nm
1\~if output line numbering is enabled
(even if temporarily suppressed),
0\~otherwise.
.
.
.TPx
.REG .ns
1\~if in no-space mode, 0\~otherwise.
.
.TPx
.REG .o
Current page offset.
.
.TPx
.REG .O
The suppression nesting level (see
.esc O ).
.
.TPx
.REG .p
Current page length.
.
.TPx
.REG .P
1\~if the current page is being printed, 0\~otherwise (as determined by
the
.option \-o
command-line option).
.
.TPx
.REG .pe
1\~during page ejection, 0\~otherwise.
.
.TPx
.REG .pn
The number of the next page: either the value set by a
.request .pn
request, or the number of the current page plus\ 1.
.
.TPx
.REG .ps
The current point size in scaled points.
.
.TPx
.REG .psr
The last-requested point size in scaled points.
.
.TPx
.REG .pvs
The current post-vertical line spacing.
.
.TPx
.REG .R
The number of unused number registers.
Always 10000 in GNU troff.
.
.TPx
.REG .rj
The number of lines to be right-justified as set by the
.request .rj
request.
.
.TPx
.REG .s
Current point size as a decimal fraction.
.
.TPx
.REG .slant
The slant of the current font as set with
.esc S .
.
.TPx
.REG .sr
The last requested point size in points as a decimal fraction
(string-valued).
.
.TPx
.REG .ss
Size of minimal inter-word spacing in twelfths of the space width of the
current font.
.
.TPx
.REG .sss
Size of additional inter-sentence spacing in twelfths of the space width
of the current font.
.
.TPx
.REG .sty
The current font style (string-valued).
.
.
.TPx
.REG .t
Distance to the next vertical position trap.
.
.
.TPx
.REG .T
Set to\~1
if option
.option \-T
is used.
.
.TPx
.REG .tabs
A string representation of the current tab settings suitable for use
as an argument to the
.request .ta
request.
.
.TPx
.REG .trunc
The amount of vertical space truncated by the most recently sprung
vertical position trap,
or,
if the trap was sprung by an
.request .ne
request,
minus the amount of vertical motion produced by
.request .ne .
.
Useful in conjunction with the
.register .ne .
.
.
.TPx
.REG .u
Equal to 1 if filling is enabled,
0 otherwise.
.
.
.TPx
.REG .U
1\~in unsafe mode and 0\~otherwise.
.
.
.TPx
.REG .v
Current vertical line spacing.
.
.TPx
.REG .V
Number of basic units per vertical unit of output device resolution.
.
.
.TPx
.REG .vpt
1\~if vertical position traps are enabled, 0\~otherwise.
.
.
.TPx
.REG .w
Width of previous glyph.
.
.TPx
.REG .warn
The sum of the number codes of the currently enabled warnings.
.
.
.TPx
.REG .x
The major version number of the running
.I \%@g@troff
formatter.
.
.
.TPx
.REG .y
The minor version number of the running
.I \%@g@troff
formatter.
.
.
.TPx
.REG .Y
The revision number of the running
.I \%@g@troff
formatter.
.
.
.TPx
.REG .z
Name of current diversion.
.
.TPx
.REG .zoom
Zoom factor for current font (in multiples of 1/1000th; zero if no
magnification).
.PD
.
.
.\" ====================================================================
.SS "Writable registers"
.\" ====================================================================
.
The following registers can be read and written by the user.
They have predefined default values, but these can be modified for
customizing a document.
.
.
.P
.PD 0
.TPx
.REG %
Current page number.
.
.TPx
.REG c.
Current input line number.
.
.TPx
.REG ct
Character type (set by width function
.esc w ).
.
.TPx
.REG dl
Maximal width of last completed diversion.
.
.TPx
.REG dn
Height of last completed diversion.
.
.TPx
.REG dw
Current day of week (1\(en7).
.
.TPx
.REG dy
Current day of month (1\(en31).
.
.TPx
.REG hours
The number of hours past midnight.
.
Initialized at start-up.
.
.TPx
.REG hp
Current horizontal position at input line.
.
.TPx
.REG llx
Lower left x-coordinate (in PostScript units) of a given PostScript
image (set by
.request .psbb ).
.
.TPx
.REG lly
Lower left y-coordinate (in PostScript units) of a given PostScript
image (set by
.request .psbb ).
.
.TPx
.REG ln
Output line number.
.
.
.TPx
.REG lsn
The count of leading spaces on an input line.
.
.
.TPx
.REG lss
The amount of horizontal space corresponding to the leading spaces
on an input line.
.
.
.TPx
.REG minutes
The number of minutes after the hour.
.
Initialized at start-up.
.
.TPx
.REG mo
Current month (1\(en12).
.
.
.TPx
.REG nl
Current vertical position.
.
.
.TPx
.REG opmaxx
.TPx
.REG opmaxy
.TPx
.REG opminx
.TPx
.REG opminy
These four registers mark the top left and bottom right hand corners of
a box which encompasses all written glyphs.
They are reset to \-1 by
.B \[rs]O0
or
.BR \[rs]O1 .
.
.TPx
.REG rsb
Like register
.BR sb ,
but takes account of the heights and depths of glyphs.
.
.TPx
.REG rst
Like register
.BR st ,
but takes account of the heights and depths of glyphs.
.
.TPx
.REG sb
Depth of string below base line (generated by width function
.esc w ).
.
.TPx
.REG seconds
The number of seconds after the minute.
.
Initialized at start-up.
.
.TPx
.REG skw
Right skip width from the center of the last glyph in the
.esc w
argument.
.
.TPx
.REG slimit
If greater than 0, the maximum number of objects on the input stack.
.
If \[<=]0 there is no limit, i.e., recursion can continue until virtual
memory is exhausted.
.
.TPx
.REG ssc
The amount of horizontal space (possibly negative) that should be
added to the last glyph before a subscript (generated by width
function
.esc w ).
.
.TPx
.REG st
Height of string above base line (generated by width function
.esc w ).
.
.TPx
.REG systat
The return value of the
.I system()
function executed by the last
.request .sy
request.
.
.TPx
.REG urx
Upper right x-coordinate (in PostScript units) of a given PostScript
image (set by
.request .psbb ).
.
.TPx
.REG ury
Upper right y-coordinate (in PostScript units) of a given PostScript
image (set by
.request .psbb ).
.
.TPx
.REG year
The current year.
.
.TPx
.REG yr
The current year minus 1900.
.
.PD
.
.
.\" ====================================================================
.SH Hyphenation
.\" ====================================================================
.
When filling,
.I groff
hyphenates words as needed at user-specified and automatically
determined hyphenation points.
.
Explicitly hyphenated words such as \[lq]mother-in-law\[rq] are eligible
for breaking after each of their hyphens.
.
The hyphenation
.RB character\~ \[rs]%
and non-printing break
.RB point\~ \[rs]:
escapes may be used to control the hyphenation and breaking of
individual words.
.
The
.B .hw
request sets user-defined hyphenation points for specified words at any
subsequent occurrence.
.
Otherwise,
.I groff
determines hyphenation points automatically by default.
.
.
.P
Several requests influence automatic hyphenation.
.
Because conventions vary,
a variety of hyphenation modes is available to the
.B .hy
request;
these determine whether hyphenation will apply to a word prior to
breaking a line at the end of a page
(more or less;
see below for details),
and at which positions within that word automatically determined
hyphenation points are permissible.
.
The default is
.RB \[lq] 1 \[rq]
for historical reasons,
but this is not an appropriate value for the English hyphenation
patterns used by
.IR groff ;
localization macro files loaded by
.I troffrc
and macro packages often override it.
.
.
.TP
.B 0
disables hyphenation.
.
.
.TP
.B 1
enables hyphenation except after the first and before the last character
of a word.
.
.
.P
The remaining values \[lq]imply\[rq]
.BR 1 ;
that is,
they enable hyphenation under the same conditions as
.RB \[lq] ".hy 1" \[rq],
and then apply or lift restrictions relative to that basis.
.
.
.TP
.B 2
disables hyphenation of the last word on a page.
.
(Technically,
hyphenation is prevented if the next page location trap is closer than
the next line of text would be.
.
.I groff
automatically inserts an implicit page location trap at the end of each
page to cause a page transition.
.
Users or macro packages can set such traps explicitly to prevent
hyphenation of the last word in a column in multi-column page layouts or
before floating figures or tables.
.
See section \[lq]Traps\[rq] below.)
.
.
.TP
.B 4
disables hyphenation before the last two characters of a word.
.
.
.TP
.B 8
disables hyphenation after the first two characters of a word.
.
.
.TP
.B 16
enables hyphenation before the last character of a word.
.
.
.TP
.B 32
enables hyphenation after the first character of a word.
.
.
.P
Apart from value\~2,
restrictions imposed by the hyphenation mode are
.I not
respected for words whose hyphenations have been explicitly specified
with the hyphenation character
.RB (\[lq] \[rs]% \[rq]
by default)
or the
.B .hw
request.
.
.
.P
The nonzero values above are additive.
.
For example,
value\~12 causes
.I groff
to hyphenate neither the last two nor the first two characters of a
word.
.
Some values cannot be used together because they contradict;
for instance,
values 4 and\~16,
and values 8 and\~32.
.
As noted,
it is superfluous to add\~1 to any nonzero even mode.
.
.
.P
The places within a word that are eligible for hyphenation are
determined by language-specific data
.RB ( .hla ,
.BR .hpf ,
and
.BR .hpfa )
and lettercase relationships
.RB ( .hcode
and
.BR .hpfcode ).
.
Furthermore,
hyphenation of a word might be suppressed because too many previous
lines have been hyphenated
.RB ( .hlm ),
the line has not reached a certain minimum length
.RB ( .hym ),
or the line can instead be adjusted with up to a certain amount of
additional inter-word space
.RB ( .hys ).
.
.
.\" ====================================================================
.SH Localization
.\" ====================================================================
.
The set of hyphenation patterns is associated with the hyphenation
language set by the
.B .hla
request.
.
The
.B .hpf
request is usually invoked by a localization file loaded by the
.I troffrc
file.
.
By default,
.I troffrc
loads the localization file for English.
.
(As of
.I groff
1.23.0,
localization files for Czech
.RI ( cs ),
German
.RI ( de ),
English
.RI ( en ),
French
.RI ( fr ),
Japanese
.RI ( ja ),
Swedish
.RI ( sv ),
and Chinese
.RI ( zh )
exist.)
.
For Western languages,
the localization file sets the hyphenation mode and loads hyphenation
patterns and exceptions.
.
It also (re-)defines translatable strings and macros that packages use
to handle localization tasks,
such as formatting the calendar date.
.
.
.\" ====================================================================
.SH "Writing macros"
.\" ====================================================================
.
The
.B .de
request defines a macro replacing the definition of any existing
request,
macro,
string,
or diversion of the same name.
.
.I \%@g@troff
stores subsequent lines to an internal buffer in \[lq]copy mode\[rq]
(see below).
.
If the optional second argument is not specified,
the macro definition ends with the control line
.RB \[lq] .. \[rq]\&
(two dots).
.
Alternatively,
a second argument names a macro whose call syntax ends the definition;
this \[lq]end macro\[rq] is then called normally.
.
Spaces or tabs are permitted after the first control character in the
line containing this ending token.
.
A tab immediately after the token prevents is recognition as the end of
a macro definition.
.
Macro definitions can be nested;
this requires use of unique end macros for each nested definition or
escaping of the line with the ending token.
.
An end macro need not be defined until it is called.
.
This fact enables a nested macro definition to begin inside one macro
and end inside another.
.
.
.P
Variants of
.B .de
that disable compatibility mode and/or indirect the names of the macros
being defined or ending the definition through a string are available as
.BR .de1 ,
.BR .dei ,
and
.BR .dei1 .
.
Existing macro definitions can be appended to with
.BR .am ,
.BR .am1 ,
.BR .ami ,
and
.BR .ami1 .
.
The
.BR .als ,
.BR .rm ,
and
.B .rn
requests create an alias of,
remove,
and rename a macro,
respectively.
.
.B .return
stops the execution of a macro immediately,
returning to the enclosing context.
.
.
.\" ====================================================================
.SS Parameters
.\" ====================================================================
.
Macro calls and string parameters can be accessed using the
.B \[rs]$
escapes.
.
The
.B \[rs]n[.$]
read-only register stores the count of parameters available to a macro
or string;
its value can be changed by the
.B .shift
request,
which dequeues parameters from the current list.
.
The
.B \[rs]$0
escape sequence interpolates the name by which a macro was called.
.
Applying string interpolation to a macro does not change this name.
.
.
.\" ====================================================================
.SS "Copy mode"
.\" ====================================================================
.
When
.I \%@g@troff
processes certain requests,
most importantly those which define or append to a macro or string,
it does so in
.IR "copy mode" :
it copies the characters of the definition into a dedicated storage
region,
interpolating the escape sequences
.BR \[rs]n ,
.BR \[rs]g ,
.BR \[rs]$ ,
.BR \[rs]* ,
and
.B \[rs]V
normally;
interpreting
.BI \[rs] newline
immediately;
discarding comments
.B \[rs]"
and
.BR \[rs]# ;
interpolating the current leader,
escape,
or tab character with
.BR \[rs]a ,
.BR \[rs]e ,
and
.BR \[rs]t ,
respectively;
and storing all other escape sequences in an encoded form.
.
The complement of copy mode\[em]a
.I roff
formatter's behavior when not defining or appending to a macro,
string,
or diversion\[em]where all macros are interpolated,
requests invoked,
and valid escape sequences processed immediately upon recognition,
can be termed
.IR "interpretation mode" .
.
.
.P
The escape character,
.B \[rs]
by default,
escapes itself.
.
Thus you can control whether a given
.BR \[rs]n ,
.BR \[rs]g ,
.BR \[rs]$ ,
.BR \[rs]* ,
or
.B \[rs]V
escape sequence is interpreted at the time the macro containing it is
defined,
or later when the macro is called.
.
.
.P
You can think of
.B \[rs]\[rs]
as a \[lq]delayed\[rq] backslash;
it is the escape character followed by a backslash from which the escape
character has removed its special meaning.
.
Consequently,
.B \[rs]\[rs]
is not an escape sequence in the usual sense.
.
In any escape sequence
.BI \[rs] X
that
.I \%@g@troff
does not recognize,
the escape character is ignored and
.IR X \~is
output,
with two exceptions,
.B \[rs]\[rs]
being one.
.
The other is
.BR \[rs]. ,
which escapes the control character.
.
It is used to permit nested macro definitions to end without a named
macro call to conclude them.
.
Without a syntax for escaping the control character,
this would not be possible.
.
.I roff
documents should not use the
.B \[rs]\[rs]
or
.B \[rs].\&
tokens outside of copy mode;
they serve only to obfuscate the input.
.
Use
.B \[rs]e
to obtain the escape character,
.B \[rs][rs]
to obtain a backslash glyph,
and
.B \[rs]&
before
.RB \[lq] .\& \[rq]
and
.RB \[lq] \[aq] \[rq]
where
.I \%@g@troff
expects them as control characters if you mean to use them literally.
.
.
.P
Macro definitions can be nested to arbitrary depth.
.
Each escape character is interpreted twice\[em]once in copy mode,
when the macro is defined,
and once in interpretation mode,
when it is executed.
.
This fact leads to exponential growth in the number of escape characters
required to delay interpolation of
.BR \[rs]n ,
.BR \[rs]g ,
.BR \[rs]$ ,
.BR \[rs]* ,
and
.B \[rs]V
at each nesting level.
.
An alternative is to use
.BR \[rs]E ,
which represents an escape character that is not interpreted in copy
mode.
.
Because
.B \[rs].\&
is not a true escape sequence,
we can't use
.B \[rs]E
to keep
.RB \[lq] ..\& \[rq]
from ending a macro definition prematurely.
.
If the multiplicity of backslashes complicates maintenance,
use end macros.
.
.
.\" ====================================================================
.SH Traps
.\" ====================================================================
.
.I Traps
are locations in the output,
or conditions on the input that,
when reached or fulfilled,
cause a specified macro to be called.
.
These traps can occur at a given location on the page
.RB ( .wh ,\~ .ch );
at a given location in the current diversion
.RB ( .dt )\[em]together,
these are known as
vertical position traps,
which can be disabled and re-enabled
.RB ( .vpt );
at a blank line
.RB ( .blm );
at a line with leading space characters
.RB ( .lsm );
after a certain number of input lines
.RB ( .it ,\~ .itc );
or at the end of input
.RB ( .em ).
.
Macros called by traps have no arguments.
.
Setting a trap is also called
.IR planting .
.
It is also said that a trap is
.I sprung
if the associated macro is executed.
.
.
.P
Registers associated with trap management include
vertical position trap enablement status
.RB ( \[rs]n[.vpt] ),
distance to the next trap
.RB ( \[rs]n[.t] ),
amount of needed
.RB ( .ne -requested )
space that caused the most recent vertical position trap to be sprung
.RB ( \[rs]n[.ne] ),
amount of needed space truncated from the amount requested
.RB ( \[rs]n[.trunc] ),
page ejection status
.RB ( \[rs]n[.pe] ),
and
leading space count
.RB ( \[rs]n[.lsn] )
with its corresponding amount of motion
.RB ( \[rs]n[.lss] ).
.
.
.\" ====================================================================
.SH Underlining
.\" ====================================================================
.
In the
.I RUNOFF
language, the underlining was quite easy.
.
But in
.I roff
this is much more difficult.
.
.
.\" ====================================================================
.SS "Underlining with .ul"
.\" ====================================================================
.
There exists a
.I groff
request
.B .ul
(see above) that can underline the next or further source lines in
.BR nroff ,
but in
.B troff
it produces only a font change into
.IR italic .
.
So this request is not really useful.
.
.
.\" ====================================================================
.SS "Underlining with .UL from \f[I]ms\f[]"
.\" ====================================================================
.
In the \[oq]ms\[cq] macro package in tmac/s.tmac
.BR groff_ms (@MAN7EXT@),
there is the macro
.BR .UL .
.
But this works only in
.BR troff ,
not in
.BR nroff .
.
.
.\" ====================================================================
.SS "Underlining macro definitions"
.\" ====================================================================
.
So one can use the
.I italic
.B nroff
idea from
.B .ul
and the
.B troff
definition
in
.I ms
for writing a useful new macro, something like
.
.RS
.EX
\&.de UNDERLINE
\&. ie n \[rs]\[rs]$1\[rs]f[I]\[rs]\[rs]$2\[rs]f[P]\[rs]\[rs]$3
\&. el \[rs]\[rs]$1\[rs]Z\[aq]\[rs]\[rs]$2\[aq]\[rs]v\[aq].25m\[aq]\
\[rs]D\[aq]l \[rs]w\[aq]\[rs]\[rs]$2\[aq]u 0\[aq]\[rs]v\[aq]\-.25m\
\[aq]\[rs]\[rs]$3
\&..
.EE
.RE
.
If
.BR doclifter (1)
makes trouble, change the macro name
.B UNDERLINE
into some 2-letter word, like
.BR Ul .
.
Moreover,
change the form of the font escape from
.B \[rs]f[P]
to
.BR \[rs]fP .
.
.
.\" ====================================================================
.SS "Underlining without macro definitions"
.\" ====================================================================
.
If one does not want to use macro definitions, e.g., when
.B doclifter
gets lost, use the following:
.
.RS
.EX
\&.ds u1 before
\&.ds u2 in
\&.ds u3 after
\&.ie n \[rs]*[u1]\[rs]f[I]\[rs]*[u2]\[rs]f[P]\[rs]*[u3]
\&.el \[rs]*[u1]\[rs]Z\[aq]\[rs]*[u2]\[aq]\[rs]v\[aq].25m\[aq]\[rs]D\
\[aq]l \[rs]w\[aq]\[rs]*[u2]\[aq]u 0\[aq]\[rs]v\[aq]\-.25m\[aq]\[rs]*\
[u3]
.EE
.RE
.
When using
.BR doclifter ,
it might be necessary to change syntax forms such as
.B \e[xy]
and
.B \e*[xy]
to those supported by AT&T
.IR troff :
.B \e*(xy
and
.BR \e(xy ,
and so on.
.
.
.P
Then these lines could look like
.RS
.EX
\&.ds u1 before
\&.ds u2 in
\&.ds u3 after
\&.ie n \[rs]*[u1]\[rs]fI\[rs]*(u2\[rs]fP\[rs]*(u3
\&.el \[rs]*(u1\[rs]Z\[aq]\[rs]*(u2\[aq]\[rs]v\[aq].25m\[aq]\[rs]D\
\[aq]l \[rs]w\[aq]\[rs]*(u2\[aq]u 0\[aq]\[rs]v\[aq]\-.25m\[aq]\[rs]*(u3
.EE
.RE
.
.
.P
The result looks like
.RS
.ft CR
before
\z\[ul]i\
\z\[ul]n
after
.ft R
.RE
.
.
.\" ====================================================================
.SS "Underlining with overstriking \ez and \e(ul"
.\" ====================================================================
.
There is another possibility for underlining by using overstriking
with
.BI \ez c
(print
.I c
with zero width without spacing) and
.B \e(ul
(underline character).
.
This produces the underlining of 1 character, both in
.B nroff
and in
.BR troff .
.
.
.P
For example the underlining of a character say
.B t
looks like
.B \ez\e[ul]t
or
.B \ez\e(ult
.
.
.P
Longer words look then a bit strange, but a useful mode is to write
each character into a whole own line.
.
To underlines the 3 character part "tar" of the word "start":
.
.RS
.EX
.br
before s\[rs]
\[rs]z\[rs][ul]t\[rs]
\[rs]z\[rs][ul]a\[rs]
\[rs]z\[rs][ul]r\[rs]
t after
.EE
.RE
.
or
.
.RS
.EX
.br
before s\[rs]
\[rs]z\[rs](ult\[rs]
\[rs]z\[rs](ula\[rs]
\[rs]z\[rs](ulr\[rs]
t after
.EE
.RE
.
.
.P
The result looks like
.RS
.ft CR
before s\
\z\[ul]t\
\z\[ul]a\
\z\[ul]r\
t after
.ft R
.RE
.
.
.\" ====================================================================
.SH Compatibility
.\" ====================================================================
.
The differences between the
.I roff
language recognized by GNU
.I troff \" GNU
and that of AT&T
.IR troff , \" AT&T
as well as the device,
font,
and device-independent intermediate output formats described by
CSTR\~#54 are documented in
.IR groff_diff (@MAN7EXT@).
.
.
.P
.I groff
provides an AT&T compatibility mode;
see
.IR groff (@MAN1EXT@).
.
.
.\" ====================================================================
.SH Debugging
.\" ====================================================================
.
.I groff
is not the easiest language to debug,
in part thanks to its design features of recursive interpolation and
multi-stage pipeline processing.
.
Nevertheless there exist several features useful for troubleshooting.
.
.
.P
Preprocessors use the
.B .lf
request to preserve the identities of line numbers and names of input
files.
.
.I groff
emits a variety of error diagnostics and supports several categories of
warning;
the output of these can be selectively suppressed with
.B .warn
(and see the
.BR \-E ,
.BR \-w ,
and
.B \-W
options of
.IR \%@g@troff (@MAN1EXT@)).
.
Backtraces can be automatically produced when errors or warnings occur
(the
.B \-b
option of
.IR \%@g@troff (@MAN1EXT@))
or generated on demand
.RB ( .backtrace ).
.
.BR .tm ,
.BR .tmc ,
and
.B .tm1
can be used to emit customized diagnostic messages or for
instrumentation while troubleshooting.
.
.B .ex
and
.B .ab
cause early termination with successful and error exit codes
respectively,
to halt further processing when continuing would be fruitless.
.
The state of the formatter can be examined with requests that write
lists of defined macros,
strings,
and diversions
.RB ( .pm );
environments
.RB ( .pev ),
registers
.RB ( .pnr ),
and page location traps
.RB ( .ptr )
to the standard error stream.
.
.
.\" ====================================================================
.SH Authors
.\" ====================================================================
.
This document was written by
.MT groff\-bernd\:.warken\-72@\:web\:.de
Bernd Warken
.ME .
.
.
.\" ====================================================================
.SH "See also"
.\" ====================================================================
.
.IR "Groff: The GNU Implementation of troff" ,
by Trent A.\& Fisher and Werner Lemberg,
is the primary
.I groff
manual.
.
You can browse it interactively with \[lq]info groff\[rq].
.
.
.P
\[lq]Troff User's Manual\[rq]
by Joseph F.\& Ossanna, 1976
(revised by Brian W.\& Kernighan, 1992),
AT&T Bell Laboratories Computing Science Techical Report No.\& 54,
widely called simply \[lq]CSTR\~#54\[rq],
documents the language,
device and font description file formats,
and device-independent output format
referred to collectively in
.I groff
documentation as
.RI \[lq]AT&T\~ troff \[rq].
.
.
.P
\[lq]A Typesetter-independent TROFF\[rq]
by Brian W.\& Kernighan, 1982,
AT&T Bell Laboratories Computing Science Techical Report No.\& 97
(CSTR\~#97),
provides additional insights into the
device and font description file formats
and device-independent output format.
.
.
.TP
.IR groff (@MAN1EXT@)
is the preferred interface to the
.I groff
system;
it manages the pipeline that carries a source document through
preprocessors,
the
.I \%@g@troff
formatter,
and an output driver to viewable or printable form.
.
It also exhaustively lists all of the man pages provided with the GNU
.I roff
system.
.
.
.TP
.IR groff_char (@MAN7EXT@)
discusses character encoding issues,
escape sequences that produce glyphs,
and enumerates
.IR groff 's
predefined special character escapes.
.
.
.TP
.IR groff_diff (@MAN7EXT@)
covers the differences between the
GNU
.I troff \" GNU
formatter,
its device and font description file formats,
its device-independent output format,
and those of AT&T
.IR troff ,\" AT&T
whose design it re-implements.
.
.
.TP
.IR groff_font (@MAN5EXT@)
describes the formats of the files that describe devices
.RI ( DESC )
and fonts.
.
.
.TP
.IR groff_tmac (@MAN5EXT@)
surveys macro packages provided with
.IR groff ,
describes how documents can take advantage of them,
offers guidance on writing macro packages and using diversions,
and includes historical information on macro package naming conventions.
.
.
.TP
.IR roff (@MAN7EXT@)
presents a detailed history of
.I roff
systems and summarizes concepts common to them.
.
.
.\" Restore compatibility mode (for, e.g., Solaris 10/11).
.cp \n[*groff_groff_7_man_C]
.do rr *groff_groff_7_man_C
.
.
.\" Local Variables:
.\" fill-column: 72
.\" mode: nroff
.\" End:
.\" vim: set filetype=groff textwidth=72:
